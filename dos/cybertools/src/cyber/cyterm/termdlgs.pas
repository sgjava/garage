{
Turbo Vision CyberTools 2.6
(C) 1994 Steve Goldsmith
All Rights Reserved
}

UNIT TERMDLGS ;{$I APP.INC} INTERFACE USES DOS , DRIVERS , MEMORY , OBJECTS , VIEWS , DIALOGS , APP , EDITORS ,
VALIDATE , STDDLG , MSGBOX , DIRVIEW , APUART , APPORT , APMISC , APTIMER , OOCOM , OOABSPCL , OOZMODEM , OOYMODEM ,
OOXMODEM , OOKERMIT , OOASCII , COMMDLGS , TVSTR ;CONST CTLINEMAX =1023 ;CTLINESMAX =1023 ;CTXFERLOGWAIT =2 ;
CTGENWAIT =2 ;CTUSEDTR =$0001 ;CTUSERTS =$0002 ;CTREQDSR =$0004 ;CTREQCTS =$0008 ;CTHARDFLOW =$000f ;CTXONXOFF =$0010 ;
CTFIFO =$0020 ;CTLOCALECHO =$0040 ;CTVT100 =$0080 ;CTRAWCAP =$0100 ;CTCMDINIT =$00000001 ;CTCMDDIAL =$00000002 ;
CTCMDDIALPAUSE =$00000004 ;CTCMDRESPWAIT =$00000008 ;CTCMDRESPREC =$00000010 ;CTCMDRESPTIME =$00000020 ;
CTCMDHANGUP =$00000040 ;CTCMDDTRLOW =$00000080 ;CTCMDCTSWAIT =$00000100 ;CTCMDCTSLOW =$00000200 ;CTCMDSCRIPT =$00000400 ;
CTCMDXFERSTAT =$00000800 ;CTCMDXFERINIT =$00001000 ;CTCMDXFER =$00002000 ;CTCMDDOWNLOAD =$00004000 ;
CTCMDXFERABORT =$00008000 ;CTCMDXFERMASK =$0000f800 ;CTCMDGENPAUSE =$00010000 ;CTANSIINVERSE =$0001 ;
CTANSIINTENSE =$0002 ;CTANSIBLINK =$0004 ;CTANSIINVIS =$0008 ;CTANSIATTR =$000f ;CTANSIESC =$1000 ;CTANSIPARAMS =$2000 ;
CTANSIKEYSTR =$4000 ;CTANSIVT100 =$8000 ;CTANSIINTMAX =20 ;CTANSISTRMAX =100 ;CTSCRSTWAITFOR =$0001 ;CTSCRSTLOGON =$0002
;CTNONE =0 ;CTPSTRING =1 ;CTPWORD =2 ;CTPLONGINT =3 ;CTPDOUBLE =4 ;CTPVARASSIGN =5 ;CTBAUDTABLE :ARRAY [ 0 .. 8 ]
 OF LONGINT =(300 , 1200 , 2400 , 4800 , 9600 , 19200 , 38400 , 57600 , 115200 );CTPARITYCHAR :ARRAY [ 0 .. 4 ]
 OF CHAR =('N', 'O', 'E', 'M', 'S');CTSEPCHAR =',';CTBELL =#7;CTBS =#8;CTTAB =#9;CTFF =#12;CTCR =#13;CTLF =#10;
CTESC =#27;CTSP =#32;CTCRLF =CTCR + CTLF ;CTLEFTBRACK ='[';CTCHARCOLOR =$0700 ;CMPHONEADD =65200 ;CMPHONEDELETE =65201 ;
CMPHONEEDIT =65202 ;CMPHONECALL =65203 ;CMTERMIDLE =65204 ;CMRUNSCRIPT =101 ;CMABORTSCRIPT =102 ;CMHANGUP =103 ;
CMECHOTOGGLE =104 ;CMABORTXFER =105 ;CMCAPTURE =106 ;PXETERMCMDS =[ CMABORTSCRIPT , CMHANGUP , CMECHOTOGGLE ,
CMABORTXFER , CMCAPTURE ] ;RSTERMREC =65000 ;RSPHONECOLL =65001 ;TYPE CTLINEBUFPTR =^CTLINEBUF ;CTLINEBUF =ARRAY [ 0 ..
CTLINEMAX ]  OF WORD ;CTSCRBUFPTR =^CTSCRBUF ;CTSCRBUF =ARRAY [ 0 .. CTLINESMAX ]  OF CTLINEBUFPTR ;CTINTPARAM =ARRAY [ 0
.. CTANSIINTMAX ]  OF INTEGER ;CTUARTPORTPTR =^CTUARTPORT ;CTUARTPORT =OBJECT (UARTPORT)UARTWIN :PVIEW ;
FUNCTION USERABORT :BOOLEAN ;VIRTUAL;PROCEDURE PUTSTRING (S :STRING );VIRTUAL;PROCEDURE SCANFORMULTISTRING (SL :STRING ;
SEPCHAR :CHAR ;VAR FOUNDS :STRING ;VAR FOUNDI :BYTE );VIRTUAL;END ;CTZMODEMPROTOCOLPTR =^CTZMODEMPROTOCOL ;
CTZMODEMPROTOCOL =OBJECT (ZMODEMPROTOCOL)PROTWIN :PVIEW ;END ;CTYMODEMPROTOCOLPTR =^CTYMODEMPROTOCOL ;
CTYMODEMPROTOCOL =OBJECT (YMODEMPROTOCOL)PROTWIN :PVIEW ;END ;CTXMODEMPROTOCOLPTR =^CTXMODEMPROTOCOL ;
CTXMODEMPROTOCOL =OBJECT (XMODEMPROTOCOL)PROTWIN :PVIEW ;END ;CTKERMITPROTOCOLPTR =^CTKERMITPROTOCOL ;
CTKERMITPROTOCOL =OBJECT (KERMITPROTOCOL)PROTWIN :PVIEW ;END ;CTASCIIPROTOCOLPTR =^CTASCIIPROTOCOL ;
CTASCIIPROTOCOL =OBJECT (ASCIIPROTOCOL)PROTWIN :PVIEW ;END ;CTSCRCOMMAND =(CTSCRWAITFOR , CTSCRSEND , CTSCRGETRESP ,
CTSCRGETBLOCK , CTSCRIFEQU , CTSCRIFNOTEQU , CTSCRIFLESS , CTSCRIFGREAT , CTSCRIFLESSEQ , CTSCRIFGREATEQ , CTSCRVARASN ,
CTSCRVARADD , CTSCRVARSUB , CTSCRVARMUL , CTSCRVARDIV , CTSCRWAITSECS , CTSCRCALL , CTSCRRETURN , CTSCRGOTO ,
CTSCRLABEL , CTSCRCAPAPP , CTSCRCAPNEW , CTSCRZMODEMD , CTSCRVARSTR , CTSCRVARINT , CTSCRVARDBL , CTSCRSEPCHAR ,
CTSCRGETCHAR , CTSCRINIT , CTSCRDIAL , CTSCRHANGUP , CTSCRLOGON , CTSCRLOGOFF , CTSCREND );PWORD =^WORD ;
PLONGINT =^LONGINT ;PDOUBLE =^DOUBLE ;PSTACKNODE =^TSTACKNODE ;TSTACKNODE =OBJECT (TOBJECT)LOC :WORD ;END ;
PVARNODE =^TVARNODE ;TVARNODE =OBJECT (TOBJECT)VARTYPE :WORD ;VARDATAPTR :POINTER ;VARNAME :PSTRING ;END ;
PVARASSIGN =^TVARASSIGN ;TVARASSIGN =RECORD VARCUR , VARNEW :PVARNODE ;END ;PSCRIPTNODE =^TSCRIPTNODE ;
TSCRIPTNODE =OBJECT (TOBJECT)SCCOMMAND :CTSCRCOMMAND ;SCDATAPTR :PVARNODE ;END ;PSCRIPTENG =^TSCRIPTENG ;
TSCRIPTENG =OBJECT (TOBJECT)SEPCHAR :CHAR ;LDOUBLE , RDOUBLE :BYTE ;SCRIPTSTATE , CURCOMMAND , WAITFORSECS :WORD ;
WAITRESP , LASTRESP :STRING ;GETBLOCKSET :CHARSET ;SCRIPTTIMER :EVENTTIMER ;NODECOLLPTR , VARCOLLPTR ,
STACKCOLLPTR :PCOLLECTION ;SCRIPTWIN :PVIEW ;CONSTRUCTOR INIT (T :PVIEW );DESTRUCTOR DONE ;VIRTUAL;
PROCEDURE DISPOSENODES ;VIRTUAL;PROCEDURE LOGERR (ERRSTR :STRING );VIRTUAL;PROCEDURE PUSHADDR (NODEADDR :WORD );
FUNCTION POPADDR :WORD ;PROCEDURE PROCESSCOMMAND ;VIRTUAL;FUNCTION ADDCOMMAND (NODE :PSCRIPTNODE ):BOOLEAN ;VIRTUAL;
FUNCTION ADDVAR (NODE :PVARNODE ):BOOLEAN ;VIRTUAL;FUNCTION GETVARPTR (VNAME :STRING ):PVARNODE ;VIRTUAL;
PROCEDURE LOGCOMMAND ;VIRTUAL;END ;PLABELNODE =^TLABELNODE ;TLABELNODE =OBJECT (TOBJECT)LOC :WORD ;NAME :PSTRING ;END ;
PSCRIPTCOMPILE =^TSCRIPTCOMPILE ;TSCRIPTCOMPILE =OBJECT (TOBJECT)CURLINE , CURCHAR , LASTCHAR , NODENUM :WORD ;CMDSTR ,
PARSTR :STRING ;CMDNUM :CTSCRCOMMAND ;LABELCOLLPTR :PCOLLECTION ;TWIN :PVIEW ;EDITWIN :PCYEDITWINDOW ;
SCRIPTENG :PSCRIPTENG ;CONSTRUCTOR INIT (E :PCYEDITWINDOW ;T :PVIEW );DESTRUCTOR DONE ;VIRTUAL;FUNCTION ADDLABEL
(NODE :PLABELNODE ):BOOLEAN ;VIRTUAL;FUNCTION GETLABELPTR (LNAME :STRING ):PLABELNODE ;VIRTUAL;FUNCTION GETLINE
(VAR TEMPSTR :STRING ):BOOLEAN ;VIRTUAL;PROCEDURE LOGERR (ERRSTR :STRING );VIRTUAL;PROCEDURE PARSELINE (S :STRING );
VIRTUAL;FUNCTION FINDCOMMAND :BOOLEAN ;VIRTUAL;FUNCTION PASS1 (S :STRING ):BOOLEAN ;VIRTUAL;FUNCTION PASS2 (S :STRING
):BOOLEAN ;VIRTUAL;FUNCTION COMPILE :BOOLEAN ;VIRTUAL;END ;PTERMREC =^TTERMREC ;TTERMREC =OBJECT (TOBJECT)NAME ,
PHONENUM :STRING [ 25 ] ;DLPATH :PATHSTR ;INITSTR :STRING [ 30 ] ;COMNAME :COMNAMETYPE ;BAUD :LONGINT ;
PARITY :PARITYTYPE ;DATABITS :DATABITTYPE ;STOPBITS :STOPBITTYPE ;COMOPTIONS , TERMOPTS :WORD ;CONSTRUCTOR LOAD
(VAR S :TSTREAM );PROCEDURE STORE (VAR S :TSTREAM );VIRTUAL;END ;PTERMGENOPTSREC =^TTERMGENOPTSREC ;
TTERMGENOPTSREC =RECORD TERMWIDTH , TERMLEN , TERMDRAW , INBUF , OUTBUF , WAITCTS , WAITRESP , WAITDTR , DIALWAIT ,
DIALPAUSE , REDIAL :WORD ;CANCELCHAR :CHAR ;DIALPREFIX :STRING [ 20 ] ;RESPOK , RESPERROR , RESPCONNECT , RESPNOCARR ,
RESPNOANS , RESPBUSY , RESPVOICE , RESPRING , RESPNOTONE :STRING [ 30 ] ;END ;CTEMUCOMMANDS =(CTEMUNONE , CTEMUCHAR ,
CTEMUGOTOXY , CTEMUUP , CTEMUDOWN , CTEMURIGHT , CTEMULEFT , CTEMUCLRBELOW , CTEMUCLRABOVE , CTEMUCLRSCR ,
CTEMUCLRENDLINE , CTEMUCLRSTARTLINE , CTEMUCLRLINE , CTEMUSETMODE , CTEMUINSLINE , CTEMUDELLINE , CTEMUINSCHAR ,
CTEMUDELCHAR , CTEMURESETMODE , CTEMUSETATTR , CTEMUSAVECURPOS , CTEMURESCURPOS , CTEMUDEVSTATREP , CTEMUKEYREMAP ,
CTEMUERROR );PANSIEMU =^TANSIEMU ;TANSIEMU =OBJECT (TOBJECT)X , Y , ATTR :BYTE ;ANSIOPTIONS , PARAMINDEX :WORD ;
ANSICMD :CTEMUCOMMANDS ;ANSICHR :CHAR ;PARAMSTR , KEYSTR :STRING ;INTPARAM :CTINTPARAM ;CONSTRUCTOR INIT
(TXTCOLOR :WORD );PROCEDURE PROCESSCHAR (C :CHAR );VIRTUAL;END ;PANSITERM =^TANSITERM ;
TANSITERM =OBJECT (TSCROLLER)XBUF , YBUF :INTEGER ;DRAWCOLOR , BUFCHARS , SAVECURX , SAVECURY , LINELEN , LINES ,
LINESIZE , MAXBUFCHARS , TERMOPTIONS :WORD ;DRAWBUF :CTSCRBUFPTR ;UPORTPTR :CTUARTPORTPTR ;ANSIEMU :TANSIEMU ;
CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;AHSCROLLBAR ,AVSCROLLBAR:PSCROLLBAR ;GENOPTSPTR :PTERMGENOPTSREC ;
APORT :CTUARTPORTPTR );DESTRUCTOR DONE ;VIRTUAL;PROCEDURE DRAW ;VIRTUAL;PROCEDURE ADJUSTBUFFER ;VIRTUAL;
PROCEDURE TRACKCURSOR ;VIRTUAL;PROCEDURE PUTVIEWCHAR ;VIRTUAL;PROCEDURE SETATTR ;VIRTUAL;PROCEDURE SETBUFXY ;VIRTUAL;
PROCEDURE CLEARSCR ;VIRTUAL;PROCEDURE CLEARBELOW ;VIRTUAL;PROCEDURE CLEARABOVE ;VIRTUAL;PROCEDURE CLEAREOL ;VIRTUAL;
PROCEDURE CLEARSOL ;VIRTUAL;PROCEDURE CLEARLINE ;VIRTUAL;PROCEDURE UP ;VIRTUAL;PROCEDURE DOWN ;VIRTUAL;PROCEDURE LEFT ;
VIRTUAL;PROCEDURE RIGHT ;VIRTUAL;PROCEDURE SAVECURPOS ;VIRTUAL;PROCEDURE RESTORECURPOS ;VIRTUAL;PROCEDURE DEVICESTATUS ;
VIRTUAL;PROCEDURE PROCANSICHAR (C :CHAR );VIRTUAL;PROCEDURE PROCINBUF ;VIRTUAL;PROCEDURE HANDLEEVENT
(VAR EVENT :TEVENT );VIRTUAL;END ;PTERMWIN =^TTERMWIN ;TTERMWIN =OBJECT (TDIALOG)CAPTUREON :BOOLEAN ;RESPFOUND :BYTE ;
REDIALCNT , PROTOCOLNUM :WORD ;CMDSTATE , FILELISTSIZE :LONGINT ;RESPSTR , RESPWAITSTR , OKSTR :STRING ;
CAPFILENAME :PATHSTR ;CAPFILE :FILE  OF CHAR ;TERMTIMER :EVENTTIMER ;TERMREC :PTERMREC ;GENOPTSREC :PTERMGENOPTSREC ;
UPORT :CTUARTPORT ;PROTOCOL :ABSTRACTPROTOCOLPTR ;UPLOADLIST :FILELISTPTR ;FILELISTCOLL :PSTRINGCOLLECTION ;
TERM :PANSITERM ;SCRIPTENG :PSCRIPTENG ;CONSTRUCTOR INIT (WINTITLE :TTITLESTR ;TERMRECPTR :PTERMREC ;
GENOPTSPTR :PTERMGENOPTSREC );DESTRUCTOR DONE ;VIRTUAL;PROCEDURE WAITCTSLOW ;VIRTUAL;PROCEDURE HANGUP ;VIRTUAL;
FUNCTION FINDLOGWIN :PLOGWIN ;VIRTUAL;PROCEDURE UPDATELOG (S :STRING );VIRTUAL;PROCEDURE UPDATELOGRAW (S :STRING ;
POSQUE :WORD );VIRTUAL;PROCEDURE GETRESP ;VIRTUAL;PROCEDURE PUTCMD (CMD ,RESP:STRING ;RSECS :WORD );VIRTUAL;
PROCEDURE INITXFER ;VIRTUAL;FUNCTION XFERSTATUSSTR :STRING ;VIRTUAL;PROCEDURE XFERTASK ;VIRTUAL;PROCEDURE INITMODEM ;
VIRTUAL;PROCEDURE DIALLOG (RAW :BOOLEAN );VIRTUAL;PROCEDURE DIAL ;VIRTUAL;PROCEDURE DIALPAUSE ;VIRTUAL;
PROCEDURE GENPAUSE ;VIRTUAL;PROCEDURE PROCESSSCRIPT ;VIRTUAL;PROCEDURE IDLETASK ;VIRTUAL;PROCEDURE CAPTURE
(FNAME :PATHSTR ;CMD :WORD );VIRTUAL;PROCEDURE CAPTURECLOSE ;VIRTUAL;PROCEDURE SETSTATE (ASTATE :WORD ;
ENABLE :BOOLEAN );VIRTUAL;PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );VIRTUAL;FUNCTION VALID (COMMAND :WORD ):BOOLEAN ;
VIRTUAL;END ;PPHONECOLLECTION =^TPHONECOLLECTION ;TPHONECOLLECTION =OBJECT (TSORTEDCOLLECTION)FUNCTION KEYOF
(ITEM :POINTER ):POINTER ;VIRTUAL;FUNCTION COMPARE (KEY1 ,KEY2:POINTER ):INTEGER ;VIRTUAL;END ;
TTERMLISTBOXREC =RECORD LIST :PPHONECOLLECTION ;SELECTION :WORD ;END ;PTERMLISTBOX =^TTERMLISTBOX ;
TTERMLISTBOX =OBJECT (TSORTEDLISTBOX)FUNCTION GETTEXT (ITEM :INTEGER ;MAXLEN :INTEGER ):STRING ;VIRTUAL;END ;
TTERMCONFIGDLGREC =RECORD PHONELIST :TTERMLISTBOXREC ;NAME , PHONENUM :STRING [ 25 ] ;DLPATH :PATHSTR ;INITSTR :STRING [
128 ] ;COMPORT , BAUD , DATABITS , PARITY , STOPBITS , TERMOPTS :INTEGER ;END ;PTERMCONFIGDLG =^TTERMCONFIGDLG ;
TTERMCONFIGDLG =OBJECT (TDIALOG)PHONECOLLPTR :PPHONECOLLECTION ;NAMELINE , PHONELINE , PATHLINE , INITLINE :PINPUTLINE ;
COMBUTTONS , BAUDBUTTONS , DATABUTTONS , PARITYBUTTONS , STOPBUTTONS :PRADIOBUTTONS ;OPTBOXES :PCHECKBOXES ;
FIELDBOX :PTERMLISTBOX ;CONSTRUCTOR INIT ;PROCEDURE ADDREC ;VIRTUAL;PROCEDURE DELETEREC ;VIRTUAL;PROCEDURE HANDLEEVENT
(VAR EVENT :TEVENT );VIRTUAL;END ;TTERMGENDLGREC =RECORD TERMWIDTHSTR , TERMLENSTR , TERMDRAWSTR , INBUFSTR , OUTBUFSTR ,
WAITCTSSTR :STRING [ 6 ] ;DIALPREFIXSTR :STRING [ 20 ] ;DIALWAITSTR , DIALPAUSESTR , REDIALSTR :STRING [ 6 ] ;
RESPOKSTR , RESPERRORSTR , RESPCONNECTSTR , RESPNOCARRSTR , RESPNOANSSTR , RESPBUSYSTR , RESPVOICESTR , RESPRINGSTR ,
RESPNOTONESTR :STRING [ 30 ] ;CANCELCHARSTR , WAITRESPSTR , WAITDTRSTR :STRING [ 6 ] ;END ;PTERMGENDLG =^TTERMGENDLG ;
TTERMGENDLG =OBJECT (TDIALOG)CONSTRUCTOR INIT ;END ;PROCEDURE GENDLGTOGENOPTS (GENDLG :TTERMGENDLGREC ;
VAR GENOPTS :TTERMGENOPTSREC );PROCEDURE REGISTERTERM ;CONST RTERMREC :TSTREAMREC =(OBJTYPE :RSTERMREC ;
VMTLINK :OFS (TYPEOF (TTERMREC )^);LOAD :@ TTERMREC . LOAD ;STORE :@ TTERMREC . STORE );
RPHONECOLLECTION :TSTREAMREC =(OBJTYPE :RSPHONECOLL ;VMTLINK :OFS (TYPEOF (TPHONECOLLECTION )^);LOAD :@
TSORTEDCOLLECTION . LOAD ;STORE :@ TSORTEDCOLLECTION . STORE );
IMPLEMENTATION CONST OIIlO011O00:ARRAY [ CTSCRWAITFOR.. CTSCREND]  OF STRING [ 20 ] =('WAITFOR', 'SEND', 'GETRESP',
'GETBLOCK', 'IF=', 'IF<>', 'IF<', 'IF>', 'IF<=', 'IF>=', 'ASSIGN', 'ADD', 'SUB', 'MUL', 'DIV', 'WAITFORSECS', 'CALL',
'RETURN', 'GOTO', 'LABEL', 'CAPTUREAPP', 'CAPTURENEW', 'DOWNLOADZMODEM', 'STRING', 'LONGINT', 'DOUBLE', 'WAITFORSEPCHAR',
'ADDGETDELIM', 'INIT', 'DIAL', 'HANGUP', 'LOGON', 'LOGOFF', 'END');PROCEDURE GENDLGTOGENOPTS (GENDLG:TTERMGENDLGREC;
VAR GENOPTS:TTERMGENOPTSREC);BEGIN WITH GENDLG DO BEGIN WITH GENOPTS DO BEGIN TERMWIDTH := STRTOINT (TERMWIDTHSTR );
TERMLEN := STRTOINT (TERMLENSTR );TERMDRAW := STRTOINT (TERMDRAWSTR );INBUF := STRTOINT (INBUFSTR );OUTBUF := STRTOINT
(OUTBUFSTR );WAITCTS := STRTOINT (WAITCTSSTR );DIALWAIT := STRTOINT (DIALWAITSTR );DIALPAUSE := STRTOINT (DIALPAUSESTR );
REDIAL := STRTOINT (REDIALSTR );WAITRESP := STRTOINT (WAITRESPSTR );WAITDTR := STRTOINT (WAITDTRSTR );CANCELCHAR := CHAR
(STRTOINT (CANCELCHARSTR ));DIALPREFIX := UPCASESTR (DIALPREFIXSTR );RESPOK := RESPOKSTR ;RESPERROR := RESPERRORSTR ;
RESPCONNECT := RESPCONNECTSTR ;RESPNOCARR := RESPNOCARRSTR ;RESPNOANS := RESPNOANSSTR ;RESPBUSY := RESPBUSYSTR ;
RESPVOICE := RESPVOICESTR ;RESPRING := RESPRINGSTR ;RESPNOTONE := RESPNOTONESTR ;END ;END ;END ;PROCEDURE REGISTERTERM ;
BEGIN REGISTERTYPE (RPHONECOLLECTION );REGISTERTYPE (RTERMREC )END ;PROCEDURE O10O11O1l101I
(O11Il1l0:ABSTRACTPROTOCOLPTR;OOlI0OO1I1Il:LOGFILETYPE);FAR ;VAR OOlOO1I0OIIl:PTERMWIN;BEGIN CASE O11Il1l0 ^. GETPROTOCOL
 OF ZMODEM :OOlOO1I0OIIl := PTERMWIN (CTZMODEMPROTOCOLPTR (O11Il1l0 )^. PROTWIN );YMODEM .. YMODEMG :OOlOO1I0OIIl :=
PTERMWIN (CTYMODEMPROTOCOLPTR (O11Il1l0 )^. PROTWIN );XMODEM .. XMODEM1KG :OOlOO1I0OIIl := PTERMWIN (CTXMODEMPROTOCOLPTR
(O11Il1l0 )^. PROTWIN );KERMIT :OOlOO1I0OIIl := PTERMWIN (CTKERMITPROTOCOLPTR (O11Il1l0 )^. PROTWIN );ASCII :OOlOO1I0OIIl
:= PTERMWIN (CTASCIIPROTOCOLPTR (O11Il1l0 )^. PROTWIN )END ;CASE OOlI0OO1I1Il  OF LFRECEIVESTART , LFTRANSMITSTART
:BEGIN OOlOO1I0OIIl ^. UPDATELOG ('  ');OOlOO1I0OIIl ^. CMDSTATE := OOlOO1I0OIIl ^. CMDSTATE OR CTCMDXFERSTAT END ;
LFRECEIVEOK , LFRECEIVEFAIL , LFRECEIVESKIP , LFTRANSMITOK , LFTRANSMITFAIL , LFTRANSMITSKIP :BEGIN IF OOlOO1I0OIIl ^.
PROTOCOL ^. BYTESTRANSFERRED > 0 THEN OOlOO1I0OIIl ^. UPDATELOGRAW (OOlOO1I0OIIl ^. XFERSTATUSSTR + ' '+ STATUSSTR
(GETASYNCSTATUS ), 0 );OOlOO1I0OIIl ^. CMDSTATE := OOlOO1I0OIIl ^. CMDSTATE AND NOT CTCMDXFERSTAT END END ;END ;
PROCEDURE OOII1O0l0I1I (Ol00IO0101OO:ABSTRACTPORTPTR;OIOI:CHAR);FAR ;VAR OOlOO1I0OIIl:PTERMWIN;BEGIN OOlOO1I0OIIl :=
PTERMWIN (CTUARTPORTPTR (Ol00IO0101OO )^. UARTWIN );OOlOO1I0OIIl ^. TERM ^. PROCANSICHAR (OIOI );IF ((OOlOO1I0OIIl ^.
TERM ^. BUFCHARS > 0 )AND (NOT OOlOO1I0OIIl ^. UPORT.CHARREADY ))OR (OOlOO1I0OIIl ^. TERM ^. BUFCHARS > OOlOO1I0OIIl ^.
TERM ^. MAXBUFCHARS )THEN BEGIN OOlOO1I0OIIl ^. TERM ^. TRACKCURSOR ;OOlOO1I0OIIl ^. TERM ^. DRAWVIEW ;OOlOO1I0OIIl ^.
TERM ^. BUFCHARS := 0 END END ;FUNCTION CTUARTPORT.USERABORT :BOOLEAN ;VAR OOlOO1I0OIIl:PTERMWIN;BEGIN OOlOO1I0OIIl :=
PTERMWIN (UARTWIN );IF OOlOO1I0OIIl ^. CMDSTATE AND CTCMDXFERABORT =0 THEN USERABORT := FALSE ELSE BEGIN OOlOO1I0OIIl ^.
CMDSTATE := OOlOO1I0OIIl ^. CMDSTATE AND NOT CTCMDXFERABORT ;USERABORT := TRUE END END ;PROCEDURE CTUARTPORT.PUTSTRING
(S:STRING );VAR OIlO:INTEGER;OOlOO1I0OIIl:PTERMWIN;BEGIN INHERITED PUTSTRING(S );OOlOO1I0OIIl := PTERMWIN (UARTWIN );
WITH OOlOO1I0OIIl^.TERM^ DO IF TERMOPTIONS AND CTLOCALECHO <> 0 THEN BEGIN FOR OIlO := 1 TO BYTE (S [ 0 ]
) DO PROCANSICHAR (S [ OIlO ] );TRACKCURSOR ;DRAWVIEW END END ;PROCEDURE CTUARTPORT.SCANFORMULTISTRING (SL:STRING ;
SEPCHAR:CHAR;VAR FOUNDS:STRING ;VAR FOUNDI:BYTE);CONST O101OOIIO1Ill=128 ;VAR OIOI:CHAR;OIlO:BYTE;OIOO000llIl:BYTE;
Ol00IOO0llOI:BYTE;O1l0lIl01I01:BYTE;OIOl0OOIII:ARRAY [ 1 .. O101OOIIO1Ill]  OF BOOLEAN;O10OIIlIlO00l:ARRAY [ 1 ..
O101OOIIO1Ill]  OF BYTE;OOIOll00100l:ARRAY [ 1 .. O101OOIIO1Ill]  OF CHAR;OOIO0IO10I1l,O10OIIlIlIlO1:WORD;
FUNCTION OO0l01Ol1lO (O10IIl0l:CHAR):BOOLEAN ;VAR OIlO:BYTE;OII0OO0lllO:BYTE;OOO0IllO0O0I:BOOLEAN;O1Ol10Ol0lOI:BYTE;
BEGIN OII0OO0lllO := 1 ;O1Ol10Ol0lOI := 1 ;Ol00IOO0llOI := 1 ;OOO0IllO0O0I := FALSE ;OO0l01Ol1lO := FALSE ;FOR OIlO := 1
TO BYTE (SL [ 0 ] ) DO IF SL [ OIlO ] =SEPCHAR THEN BEGIN IF NOT OOO0IllO0O0I THEN OIOl0OOIII [ Ol00IOO0llOI ] := FALSE
ELSE IF OIOl0OOIII [ Ol00IOO0llOI ] THEN BEGIN IF O10OIIlIlO00l [ Ol00IOO0llOI ] =O1Ol10Ol0lOI - 1 THEN BEGIN OO0l01Ol1lO
:= TRUE ;O1l0lIl01I01 := Ol00IOO0llOI END ELSE INC (O10OIIlIlO00l [ Ol00IOO0llOI ] )END ;INC (Ol00IOO0llOI );
O1Ol10Ol0lOI := 1 END ELSE BEGIN IF O1Ol10Ol0lOI =O10OIIlIlO00l [ Ol00IOO0llOI ] THEN IF O10IIl0l <> SL [ OIlO ] THEN
BEGIN OIOl0OOIII [ Ol00IOO0llOI ] := FALSE ;O10OIIlIlO00l [ Ol00IOO0llOI ] := 1 ;IF OOIOll00100l [ Ol00IOO0llOI ]
=O10IIl0l THEN BEGIN OIOl0OOIII [ Ol00IOO0llOI ] := TRUE ;OOO0IllO0O0I := TRUE END END ELSE BEGIN OOO0IllO0O0I := TRUE ;
OIOl0OOIII [ Ol00IOO0llOI ] := TRUE ;IF OIlO =LENGTH (SL )THEN BEGIN OO0l01Ol1lO := TRUE ;O1l0lIl01I01 := Ol00IOO0llOI
END END ;INC (O1Ol10Ol0lOI )END ;IF NOT OOO0IllO0O0I THEN OIOl0OOIII [ Ol00IOO0llOI ] := FALSE ELSE IF OIOl0OOIII [
Ol00IOO0llOI ] THEN BEGIN IF (O10OIIlIlO00l [ Ol00IOO0llOI ] =O1Ol10Ol0lOI - 1 )THEN BEGIN OO0l01Ol1lO := TRUE ;
O1l0lIl01I01 := Ol00IOO0llOI END ELSE INC (O10OIIlIlO00l [ Ol00IOO0llOI ] )END ;O10OIIlIlIlO1 := OIOO000llIl ;
WHILE (O10OIIlIlIlO1 > 0 )AND (NOT OIOl0OOIII [ O10OIIlIlIlO1 ] ) DO DEC (O10OIIlIlIlO1 );IF O10OIIlIlIlO1 =0 THEN
BEGIN DEC (OOIO0IO10I1l );GETCHAR (OIOI );WAITCHAR (@ SELF , OIOI )END END ;FUNCTION OOllO1lOlIO1
(OII0OO0lllO:BYTE):STRING ;VAR OIlO:BYTE;O1l0I01100Il:BYTE;OO1O:STRING ;OIO0O1I11lO:BYTE;OIOO0OlIO00:BYTE;
BEGIN O1l0I01100Il := 1 ;OIOO0OlIO00 := 0 ;OIlO := 1 ;WHILE (OIlO <= LENGTH (SL )) DO IF (SL [ OIlO ] =SEPCHAR )OR (OIlO
=BYTE (SL [ 0 ] ))THEN BEGIN INC (OIOO0OlIO00 );IF OIOO0OlIO00 =OII0OO0lllO THEN BEGIN IF (SL [ OIlO ] <> SEPCHAR )AND
(OIlO =BYTE (SL [ 0 ] ))THEN OIO0O1I11lO := (OIlO - O1l0I01100Il )+ 1 ELSE OIO0O1I11lO := OIlO - O1l0I01100Il ;MOVE (SL [
O1l0I01100Il ] , OO1O [ 1 ] , OIO0O1I11lO );OO1O [ 0 ] := CHAR (OIO0O1I11lO );OOllO1lOlIO1 := OO1O ;EXIT END ELSE
BEGIN O1l0I01100Il := OIlO + 1 ;INC (OIlO )END END ELSE INC (OIlO );OOllO1lOlIO1 := ''END ;BEGIN ASYNCSTATUS := 0 ;
FOUNDS := '';FOUNDI := 0 ;OOIO0IO10I1l := 1 ;IF SL =''THEN GOTERROR (EPNONFATAL + ECINVALIDARGUMENT );IF FLAGISSET (PR ^.
FLAGS , PTIGNOREDELIMCASE )THEN FOR OIlO := 1 TO BYTE (SL [ 0 ] ) DO SL [ OIlO ] := UPCASE (SL [ OIlO ] );OIOO000llIl :=
1 ;OOIOll00100l [ 1 ] := SL [ 1 ] ;FOR OIlO := 1 TO BYTE (SL [ 0 ] ) DO IF SL [ OIlO ] =SEPCHAR THEN BEGIN INC
(OIOO000llIl );IF OIlO < 255 THEN OOIOll00100l [ OIOO000llIl ] := SL [ OIlO + 1 ] END ;IF (OIOO000llIl > 255 )OR
(OIOO000llIl =0 )THEN GOTERROR (EPNONFATAL + ECINVALIDARGUMENT );FILLCHAR (OIOl0OOIII , O101OOIIO1Ill , 0 );FILLCHAR
(O10OIIlIlO00l , O101OOIIO1Ill , 1 );PEEKCHAR (OIOI , OOIO0IO10I1l );WHILE ASYNCSTATUS =ECOK  DO BEGIN IF FLAGISSET (PR
^. FLAGS , PTIGNOREDELIMCASE )THEN OIOI := UPCASE (OIOI );IF OO0l01Ol1lO (OIOI )THEN BEGIN FOUNDI := O1l0lIl01I01 ;
FOUNDS := OOllO1lOlIO1 (O1l0lIl01I01 );FOR O10OIIlIlIlO1 := 1 TO OOIO0IO10I1l  DO BEGIN GETCHAR (OIOI );WAITCHAR (@ SELF
, OIOI )END ;EXIT END ;INC (OOIO0IO10I1l );PEEKCHAR (OIOI , OOIO0IO10I1l )END END ;CONSTRUCTOR TSCRIPTENG.INIT (T:PVIEW);
BEGIN INHERITED INIT;SCRIPTWIN := T ;NODECOLLPTR := NEW (PCOLLECTION , INIT (0 , 50 ));VARCOLLPTR := NEW (PCOLLECTION ,
INIT (0 , 50 ));STACKCOLLPTR := NEW (PCOLLECTION , INIT (0 , 10 ));SEPCHAR := CTSEPCHAR ;GETBLOCKSET := [ ] ;WAITFORSECS
:= 60 ;LDOUBLE := 10 ;RDOUBLE := 2 END ;DESTRUCTOR TSCRIPTENG.DONE ;BEGIN DISPOSENODES ;INHERITED DONE END ;
PROCEDURE TSCRIPTENG.DISPOSENODES ;PROCEDURE O1lI011O0OOl (OI1000l1II00:POINTER);FAR ;VAR OOI1:PVARNODE;BEGIN OOI1 :=
PVARNODE (OI1000l1II00 );IF OOI1 ^. VARDATAPTR <> NIL THEN CASE OOI1 ^. VARTYPE  OF CTPSTRING :DISPOSESTR (PSTRING (OOI1
^. VARDATAPTR ));CTPWORD :DISPOSE (PWORD (OOI1 ^. VARDATAPTR ));CTPLONGINT :DISPOSE (PLONGINT (OOI1 ^. VARDATAPTR ));
CTPDOUBLE :DISPOSE (PDOUBLE (OOI1 ^. VARDATAPTR ));CTPVARASSIGN :DISPOSE (PVARASSIGN (OOI1 ^. VARDATAPTR ))END ;IF OOI1
^. VARNAME <> NIL THEN DISPOSESTR (OOI1 ^. VARNAME )END ;BEGIN IF VARCOLLPTR <> NIL THEN BEGIN VARCOLLPTR ^. FOREACH (@
O1lI011O0OOl );DISPOSE (VARCOLLPTR , DONE );VARCOLLPTR := NIL END ;IF NODECOLLPTR <> NIL THEN BEGIN DISPOSE (NODECOLLPTR
, DONE );NODECOLLPTR := NIL END ;IF STACKCOLLPTR <> NIL THEN BEGIN DISPOSE (STACKCOLLPTR , DONE );STACKCOLLPTR := NIL END
END ;PROCEDURE TSCRIPTENG.LOGERR (ERRSTR:STRING );BEGIN PTERMWIN (SCRIPTWIN )^. UPDATELOG ('Engine error: '+ ERRSTR );
WITH PTERMWIN(SCRIPTWIN)^ DO CMDSTATE := CMDSTATE AND NOT CTCMDSCRIPT END ;PROCEDURE TSCRIPTENG.PUSHADDR (NODEADDR:WORD);
VAR OO1O:PSTACKNODE;BEGIN OO1O := NEW (PSTACKNODE , INIT );OO1O ^. LOC := NODEADDR ;STACKCOLLPTR ^. INSERT (OO1O );IF
LOWMEMORY THEN LOGERR ('stack out of memory')END ;FUNCTION TSCRIPTENG.POPADDR :WORD ;VAR OO1O:PSTACKNODE;BEGIN IF
STACKCOLLPTR ^. COUNT > 0 THEN BEGIN OO1O := STACKCOLLPTR ^. AT (STACKCOLLPTR ^. COUNT - 1 );POPADDR := OO1O ^. LOC ;
STACKCOLLPTR ^. FREE (OO1O )END ELSE LOGERR ('stack empty')END ;PROCEDURE TSCRIPTENG.PROCESSCOMMAND ;
VAR O10OIIO1Oll0l:BOOLEAN;O1011l0IO0O:BYTE;O1l0I011011l:WORD;OOO0IlO0OI1O:STRING ;OO0O:PSCRIPTNODE;OOI1:PVARNODE;
BEGIN OO0O := PSCRIPTNODE (NODECOLLPTR ^. AT (CURCOMMAND ));OOI1 := OO0O ^. SCDATAPTR ;
WITH PTERMWIN(SCRIPTWIN)^ DO BEGIN CASE OO0O ^. SCCOMMAND  OF CTSCRWAITFOR :BEGIN IF SCRIPTSTATE AND CTSCRSTWAITFOR <> 0
THEN BEGIN IF NOT TIMEREXPIRED (SCRIPTTIMER )THEN BEGIN UPORT.SCANFORMULTISTRING (WAITRESP , SEPCHAR , LASTRESP ,
O1011l0IO0O );IF O1011l0IO0O > 0 THEN BEGIN SCRIPTSTATE := SCRIPTSTATE AND NOT CTSCRSTWAITFOR ;INC (CURCOMMAND )END END
ELSE BEGIN UPDATELOG ('Time out');LASTRESP := '';SCRIPTSTATE := SCRIPTSTATE AND NOT CTSCRSTWAITFOR ;INC (CURCOMMAND )END
END ELSE BEGIN IF OOI1 ^. VARDATAPTR <> NIL THEN BEGIN LOGCOMMAND ;CASE OOI1 ^. VARTYPE  OF CTPSTRING :WAITRESP :=
PSTRING (OOI1 ^. VARDATAPTR )^;CTPLONGINT :WAITRESP := INTTOSTR (PLONGINT (OOI1 ^. VARDATAPTR )^);CTPDOUBLE :WAITRESP :=
TRIMSTR (DBLTOSTR (PDOUBLE (OOI1 ^. VARDATAPTR )^, LDOUBLE , RDOUBLE ))END ;NEWTIMERSECS (SCRIPTTIMER , WAITFORSECS );
SCRIPTSTATE := SCRIPTSTATE OR CTSCRSTWAITFOR END ELSE BEGIN SCRIPTSTATE := SCRIPTSTATE AND NOT CTSCRSTWAITFOR ;INC
(CURCOMMAND )END END END ;CTSCRSEND :BEGIN LOGCOMMAND ;IF OOI1 ^. VARDATAPTR <> NIL THEN CASE OOI1 ^. VARTYPE
 OF CTPSTRING :UPORT.PUTSTRING (PSTRING (OOI1 ^. VARDATAPTR )^);CTPLONGINT :UPORT.PUTSTRING (INTTOSTR (PLONGINT (OOI1 ^.
VARDATAPTR )^));CTPDOUBLE :UPORT.PUTSTRING (TRIMSTR (DBLTOSTR (PDOUBLE (OOI1 ^. VARDATAPTR )^, LDOUBLE , RDOUBLE )))END ;
INC (CURCOMMAND )END ;CTSCRGETRESP :BEGIN IF OOI1 ^. VARDATAPTR <> NIL THEN DISPOSESTR (PSTRING (OOI1 ^. VARDATAPTR ));
IF LASTRESP <> ''THEN OOI1 ^. VARDATAPTR := NEWSTR (LASTRESP )ELSE OOI1 ^. VARDATAPTR := NIL ;LOGCOMMAND ;INC (CURCOMMAND
)END ;CTSCRGETBLOCK :BEGIN LOGCOMMAND ;INC (CURCOMMAND )END ;CTSCRIFEQU , CTSCRIFNOTEQU , CTSCRIFLESS , CTSCRIFGREAT ,
CTSCRIFLESSEQ , CTSCRIFGREATEQ :BEGIN LOGCOMMAND ;WITH PVARASSIGN(OOI1^.VARDATAPTR)^ DO BEGIN CASE VARCUR ^. VARTYPE
 OF CTPSTRING :BEGIN IF (VARCUR ^. VARDATAPTR <> NIL )AND (VARNEW ^. VARDATAPTR <> NIL )THEN BEGIN CASE OO0O ^. SCCOMMAND
 OF CTSCRIFEQU :O10OIIO1Oll0l := PSTRING (VARCUR ^. VARDATAPTR )^=PSTRING (VARNEW ^. VARDATAPTR )^;CTSCRIFNOTEQU
:O10OIIO1Oll0l := PSTRING (VARCUR ^. VARDATAPTR )^<> PSTRING (VARNEW ^. VARDATAPTR )^;CTSCRIFLESS :O10OIIO1Oll0l :=
PSTRING (VARCUR ^. VARDATAPTR )^< PSTRING (VARNEW ^. VARDATAPTR )^;CTSCRIFGREAT :O10OIIO1Oll0l := PSTRING (VARCUR ^.
VARDATAPTR )^> PSTRING (VARNEW ^. VARDATAPTR )^;CTSCRIFLESSEQ :O10OIIO1Oll0l := PSTRING (VARCUR ^. VARDATAPTR )^<=
PSTRING (VARNEW ^. VARDATAPTR )^;CTSCRIFGREATEQ :O10OIIO1Oll0l := PSTRING (VARCUR ^. VARDATAPTR )^>= PSTRING (VARNEW ^.
VARDATAPTR )^END END ELSE CASE OO0O ^. SCCOMMAND  OF CTSCRIFEQU :O10OIIO1Oll0l := ((VARCUR ^. VARDATAPTR =NIL )AND
(VARNEW ^. VARDATAPTR =NIL ));CTSCRIFNOTEQU :O10OIIO1Oll0l := NOT ((VARCUR ^. VARDATAPTR =NIL )AND (VARNEW ^. VARDATAPTR
=NIL ));CTSCRIFLESS :O10OIIO1Oll0l := ((VARCUR ^. VARDATAPTR =NIL )AND (VARNEW ^. VARDATAPTR <> NIL ));CTSCRIFGREAT
:O10OIIO1Oll0l := ((VARCUR ^. VARDATAPTR <> NIL )AND (VARNEW ^. VARDATAPTR =NIL ));CTSCRIFLESSEQ :O10OIIO1Oll0l :=
((VARCUR ^. VARDATAPTR =NIL )AND (VARNEW ^. VARDATAPTR <> NIL ))OR ((VARCUR ^. VARDATAPTR =NIL )AND (VARNEW ^. VARDATAPTR
=NIL ));CTSCRIFGREATEQ :O10OIIO1Oll0l := ((VARCUR ^. VARDATAPTR <> NIL )AND (VARNEW ^. VARDATAPTR =NIL ))OR ((VARCUR ^.
VARDATAPTR =NIL )AND (VARNEW ^. VARDATAPTR =NIL ))END END ;CTPLONGINT :BEGIN O10OIIO1Oll0l := FALSE END ;CTPDOUBLE
:BEGIN O10OIIO1Oll0l := FALSE END END END ;IF NOT O10OIIO1Oll0l THEN INC (CURCOMMAND );INC (CURCOMMAND )END ;CTSCRVARADD
, CTSCRVARSUB , CTSCRVARMUL , CTSCRVARDIV :BEGIN LOGCOMMAND ;WITH PVARASSIGN(OOI1^.VARDATAPTR)^ DO BEGIN CASE VARCUR ^.
VARTYPE  OF CTPSTRING :BEGIN CASE OO0O ^. SCCOMMAND  OF CTSCRVARADD :BEGIN IF VARCUR ^. VARDATAPTR <> NIL THEN
BEGIN OOO0IlO0OI1O := PSTRING (VARCUR ^. VARDATAPTR )^;DISPOSESTR (PSTRING (VARCUR ^. VARDATAPTR ));END ELSE OOO0IlO0OI1O
:= '';IF VARNEW ^. VARDATAPTR <> NIL THEN VARCUR ^. VARDATAPTR := NEWSTR (OOO0IlO0OI1O + PSTRING (VARNEW ^. VARDATAPTR
)^)END END END ;CTPLONGINT :;CTPDOUBLE :END END ;INC (CURCOMMAND )END ;CTSCRVARASN :BEGIN LOGCOMMAND ;
WITH PVARASSIGN(OOI1^.VARDATAPTR)^ DO BEGIN CASE VARCUR ^. VARTYPE  OF CTPSTRING :BEGIN IF VARCUR ^. VARDATAPTR <> NIL
THEN DISPOSESTR (PSTRING (VARCUR ^. VARDATAPTR ));IF VARNEW ^. VARDATAPTR <> NIL THEN VARCUR ^. VARDATAPTR := NEWSTR
(PSTRING (VARNEW ^. VARDATAPTR )^)ELSE VARCUR ^. VARDATAPTR := NIL ;END ;CTPLONGINT :PLONGINT (VARCUR ^. VARDATAPTR )^:=
PLONGINT (VARNEW ^. VARDATAPTR )^;CTPDOUBLE :PDOUBLE (VARCUR ^. VARDATAPTR )^:= PDOUBLE (VARNEW ^. VARDATAPTR )^END END ;
INC (CURCOMMAND )END ;CTSCRCALL :BEGIN LOGCOMMAND ;PUSHADDR (CURCOMMAND + 1 );IF CMDSTATE AND CTCMDSCRIPT <> 0 THEN
CURCOMMAND := PWORD (OOI1 ^. VARDATAPTR )^END ;CTSCRRETURN :BEGIN LOGCOMMAND ;CURCOMMAND := POPADDR END ;CTSCRGOTO
:BEGIN LOGCOMMAND ;CURCOMMAND := PWORD (OOI1 ^. VARDATAPTR )^END ;CTSCRWAITSECS :BEGIN LOGCOMMAND ;WAITFORSECS :=
PLONGINT (OOI1 ^. VARDATAPTR )^;INC (CURCOMMAND )END ;CTSCRSEPCHAR :BEGIN LOGCOMMAND ;IF OOI1 ^. VARDATAPTR <> NIL THEN
SEPCHAR := PSTRING (OOI1 ^. VARDATAPTR )^[ 1 ] ;INC (CURCOMMAND )END ;CTSCRGETCHAR :BEGIN LOGCOMMAND ;IF OOI1 ^.
VARDATAPTR <> NIL THEN GETBLOCKSET := GETBLOCKSET + [ PSTRING (OOI1 ^. VARDATAPTR )^[ 1 ] ] ;INC (CURCOMMAND )END ;
CTSCRCAPAPP :BEGIN LOGCOMMAND ;IF OOI1 ^. VARDATAPTR <> NIL THEN CAPTURE (PSTRING (OOI1 ^. VARDATAPTR )^, CMYES );INC
(CURCOMMAND )END ;CTSCRCAPNEW :BEGIN LOGCOMMAND ;IF OOI1 ^. VARDATAPTR <> NIL THEN CAPTURE (PSTRING (OOI1 ^. VARDATAPTR
)^, CMNO );INC (CURCOMMAND )END ;CTSCRZMODEMD :BEGIN LOGCOMMAND ;INC (CURCOMMAND )END ;CTSCRHANGUP :BEGIN LOGCOMMAND ;IF
VALID (CMCLOSE )THEN CMDSTATE := (CMDSTATE AND NOT CTCMDDIALPAUSE )OR CTCMDHANGUP ;INC (CURCOMMAND )END ;CTSCRDIAL
:BEGIN IF SCRIPTSTATE AND CTSCRSTWAITFOR <> 0 THEN BEGIN SCRIPTSTATE := SCRIPTSTATE AND NOT CTSCRSTWAITFOR ;INC
(CURCOMMAND )END ELSE BEGIN LOGCOMMAND ;SCRIPTSTATE := SCRIPTSTATE OR CTSCRSTWAITFOR ;CMDSTATE := CMDSTATE OR CTCMDDIAL
END END ;CTSCRINIT :BEGIN IF SCRIPTSTATE AND CTSCRSTWAITFOR <> 0 THEN BEGIN SCRIPTSTATE := SCRIPTSTATE AND NOT
CTSCRSTWAITFOR ;INC (CURCOMMAND )END ELSE BEGIN LOGCOMMAND ;SCRIPTSTATE := SCRIPTSTATE OR CTSCRSTWAITFOR ;CMDSTATE :=
CMDSTATE OR CTCMDINIT END END ;CTSCRLOGON :BEGIN LOGCOMMAND ;SCRIPTSTATE := SCRIPTSTATE OR CTSCRSTLOGON ;INC (CURCOMMAND
)END ;CTSCRLOGOFF :BEGIN LOGCOMMAND ;SCRIPTSTATE := SCRIPTSTATE AND NOT CTSCRSTLOGON ;INC (CURCOMMAND )END ;CTSCREND
:BEGIN LOGCOMMAND ;CMDSTATE := CMDSTATE AND NOT CTCMDSCRIPT ;UPDATELOG ('End script')END END END END ;
FUNCTION TSCRIPTENG.ADDCOMMAND (NODE:PSCRIPTNODE):BOOLEAN ;BEGIN NODECOLLPTR ^. INSERT (NODE );ADDCOMMAND := NOT
LOWMEMORY END ;FUNCTION TSCRIPTENG.ADDVAR (NODE:PVARNODE):BOOLEAN ;BEGIN VARCOLLPTR ^. INSERT (NODE );ADDVAR := NOT
LOWMEMORY END ;FUNCTION TSCRIPTENG.GETVARPTR (VNAME:STRING ):PVARNODE ;FUNCTION O10l (OI1000l1II00:POINTER):BOOLEAN ;FAR
;BEGIN O10l := (PVARNODE (OI1000l1II00 )^. VARNAME <> NIL )AND (PVARNODE (OI1000l1II00 )^. VARNAME ^=VNAME )END ;
BEGIN VNAME := UPCASESTR (VNAME );GETVARPTR := VARCOLLPTR ^. FIRSTTHAT (@ O10l )END ;PROCEDURE TSCRIPTENG.LOGCOMMAND ;
VAR Ol00IO0I1ll0:STRING ;OO0O:PSCRIPTNODE;OOI1:PVARNODE;BEGIN IF (SCRIPTSTATE AND CTSCRSTLOGON <> 0 )AND (CURCOMMAND <=
NODECOLLPTR ^. COUNT - 1 )THEN BEGIN OO0O := PSCRIPTNODE (NODECOLLPTR ^. AT (CURCOMMAND ));OOI1 := OO0O ^. SCDATAPTR ;
Ol00IO0I1ll0 := INTTORIGHTSTR (CURCOMMAND , 6 )+ ' '+ OIIlO011O00 [ OO0O ^. SCCOMMAND ] ;IF (OOI1 <> NIL )THEN CASE OOI1
^. VARTYPE  OF CTPSTRING :IF OOI1 ^. VARDATAPTR <> NIL THEN Ol00IO0I1ll0 := Ol00IO0I1ll0 + ' '#39+ PSTRING (OOI1 ^.
VARDATAPTR )^+ #39ELSE Ol00IO0I1ll0 := Ol00IO0I1ll0 + ' '#39#39;CTPLONGINT :Ol00IO0I1ll0 := Ol00IO0I1ll0 + ' '+ INTTOSTR
(PLONGINT (OOI1 ^. VARDATAPTR )^);CTPDOUBLE :Ol00IO0I1ll0 := Ol00IO0I1ll0 + ' '+ TRIMSTR (DBLTOSTR (PDOUBLE (OOI1 ^.
VARDATAPTR )^, LDOUBLE , RDOUBLE ));CTPWORD :Ol00IO0I1ll0 := Ol00IO0I1ll0 + ' '+ INTTOSTR (PWORD (OOI1 ^. VARDATAPTR )^);
CTPVARASSIGN :BEGIN WITH PVARASSIGN(OOI1^.VARDATAPTR)^ DO BEGIN Ol00IO0I1ll0 := Ol00IO0I1ll0 + ' '+ VARCUR ^. VARNAME ^+
', ';IF VARNEW ^. VARNAME <> NIL THEN Ol00IO0I1ll0 := Ol00IO0I1ll0 + VARNEW ^. VARNAME ^ELSE CASE VARNEW ^. VARTYPE
 OF CTPSTRING :IF VARNEW ^. VARDATAPTR <> NIL THEN Ol00IO0I1ll0 := Ol00IO0I1ll0 + #39+ PSTRING (VARNEW ^. VARDATAPTR )^+
#39ELSE Ol00IO0I1ll0 := Ol00IO0I1ll0 + #39#39;CTPLONGINT :Ol00IO0I1ll0 := Ol00IO0I1ll0 + INTTOSTR (PLONGINT (VARNEW ^.
VARDATAPTR )^);CTPDOUBLE :Ol00IO0I1ll0 := Ol00IO0I1ll0 + TRIMSTR (DBLTOSTR (PDOUBLE (VARNEW ^. VARDATAPTR )^, LDOUBLE ,
RDOUBLE ));END END END END ;PTERMWIN (SCRIPTWIN )^. UPDATELOG (Ol00IO0I1ll0 )END END ;CONSTRUCTOR TSCRIPTCOMPILE.INIT
(E:PCYEDITWINDOW;T:PVIEW);BEGIN INHERITED INIT;LABELCOLLPTR := NEW (PCOLLECTION , INIT (0 , 5 ));EDITWIN := E ;TWIN := T
;SCRIPTENG := PTERMWIN (TWIN )^. SCRIPTENG END ;DESTRUCTOR TSCRIPTCOMPILE.DONE ;PROCEDURE O1lI011O0OOl
(OI1000l1II00:POINTER);FAR ;VAR OO01:PLABELNODE;BEGIN OO01 := PLABELNODE (OI1000l1II00 );IF OO01 ^. NAME <> NIL THEN
DISPOSESTR (OO01 ^. NAME )END ;BEGIN IF LABELCOLLPTR <> NIL THEN BEGIN LABELCOLLPTR ^. FOREACH (@ O1lI011O0OOl );DISPOSE
(LABELCOLLPTR , DONE )END ;INHERITED DONE END ;FUNCTION TSCRIPTCOMPILE.ADDLABEL (NODE:PLABELNODE):BOOLEAN ;
BEGIN LABELCOLLPTR ^. INSERT (NODE );ADDLABEL := NOT LOWMEMORY END ;FUNCTION TSCRIPTCOMPILE.GETLABELPTR (LNAME:STRING
):PLABELNODE ;FUNCTION O10l (OI1000l1II00:POINTER):BOOLEAN ;FAR ;BEGIN O10l := (PLABELNODE (OI1000l1II00 )^. NAME <> NIL
)AND (PLABELNODE (OI1000l1II00 )^. NAME ^=LNAME )END ;BEGIN LNAME := UPCASESTR (LNAME );GETLABELPTR := LABELCOLLPTR ^.
FIRSTTHAT (@ O10l )END ;FUNCTION TSCRIPTCOMPILE.GETLINE (VAR TEMPSTR:STRING ):BOOLEAN ;VAR OIIO1l01OI:BOOLEAN;OIOI:CHAR;
BEGIN OIIO1l01OI := FALSE ;TEMPSTR := '';LASTCHAR := CURCHAR ;GETLINE := CURCHAR < EDITWIN ^. EDITOR ^. BUFLEN ;
WHILE (CURCHAR < EDITWIN ^. EDITOR ^. BUFLEN )AND (BYTE (TEMPSTR [ 0 ] )< 255 )AND (NOT OIIO1l01OI ) DO BEGIN OIOI :=
EDITWIN ^. EDITOR ^. BUFCHAR (CURCHAR );CASE OIOI  OF CTCR :INC (CURCHAR );CTLF :BEGIN INC (CURCHAR );OIIO1l01OI := TRUE
END ELSE BEGIN TEMPSTR := TEMPSTR + EDITWIN ^. EDITOR ^. BUFCHAR (CURCHAR );INC (CURCHAR )END END END END ;
PROCEDURE TSCRIPTCOMPILE.LOGERR (ERRSTR:STRING );BEGIN PTERMWIN (TWIN )^. UPDATELOG ('Error line '+ INTTOSTR (CURLINE )+
': '+ ERRSTR );WITH EDITWIN^ DO BEGIN EDITOR ^. SETSELECT (LASTCHAR , CURCHAR - 2 , TRUE );EDITOR ^. TRACKCURSOR (TRUE );
SELECT END END ;PROCEDURE TSCRIPTCOMPILE.PARSELINE (S:STRING );VAR O10110lOl0IO0:BYTE;BEGIN O10110lOl0IO0 := POS (' ', S
);IF O10110lOl0IO0 > 1 THEN BEGIN CMDSTR := UPCASESTR (COPY (S , 1 , O10110lOl0IO0 - 1 ));PARSTR := TRIMSTR (COPY (S ,
O10110lOl0IO0 , BYTE (S [ 0 ] )- O10110lOl0IO0 + 1 ))END ELSE BEGIN CMDSTR := UPCASESTR (S );PARSTR := ''END END ;
FUNCTION TSCRIPTCOMPILE.FINDCOMMAND :BOOLEAN ;BEGIN CMDNUM := CTSCRWAITFOR ;WHILE (CMDNUM <= CTSCREND )AND (OIIlO011O00 [
CMDNUM ] <> CMDSTR ) DO INC (CMDNUM );FINDCOMMAND := (CMDNUM <= CTSCREND )END ;FUNCTION TSCRIPTCOMPILE.PASS1 (S:STRING
):BOOLEAN ;VAR O101I0OOI00OI:BOOLEAN;OIOIll010O0:LONGINT;OI1IO10lI11:DOUBLE;O1lIlOI11OIO,OOO0lI0llI0l:STRING ;
FUNCTION OI1001l01l0O :BOOLEAN ;BEGIN CASE UPCASE (PARSTR [ 1 ] ) OF 'A'.. 'Z':BEGIN O101I0OOI00OI := TRUE ;OI1001l01l0O
:= TRUE END ;#39:BEGIN O101I0OOI00OI := FALSE ;DELETE (PARSTR , 1 , 1 );IF (PARSTR <> '')AND (PARSTR [ BYTE (PARSTR [ 0 ]
)] =#39)THEN BEGIN DEC (BYTE (PARSTR [ 0 ] ));OI1001l01l0O := TRUE END ELSE BEGIN LOGERR ('no ending '#39' found');
OI1001l01l0O := FALSE END END ;'#':BEGIN O101I0OOI00OI := FALSE ;DELETE (PARSTR , 1 , 1 );PARSTR := CHAR (STRTOINT
(PARSTR ));OI1001l01l0O := TRUE END ELSE BEGIN LOGERR ('param must start with '#39', # or A..Z');OI1001l01l0O := FALSE
END END END ;FUNCTION OI0l0I0010IO :BOOLEAN ;BEGIN CASE PARSTR [ 1 ]  OF '0'.. '9', '-', '+':BEGIN OIOIll010O0 :=
STRTOINT (PARSTR );O101I0OOI00OI := FALSE ;OI0l0I0010IO := TRUE END ;'A'.. 'Z':BEGIN O101I0OOI00OI := TRUE ;OI0l0I0010IO
:= TRUE END ELSE BEGIN LOGERR ('param must start with +, -, 0..9 or A..Z');OI0l0I0010IO := FALSE END END END ;
FUNCTION OI1O0IO00OO0 :BOOLEAN ;BEGIN CASE PARSTR [ 1 ]  OF '0'.. '9', '-', '+', '.':BEGIN OI1IO10lI11 := STRTODBL
(PARSTR );O101I0OOI00OI := FALSE ;OI1O0IO00OO0 := TRUE END ;'A'.. 'Z':BEGIN O101I0OOI00OI := TRUE ;OI1O0IO00OO0 := TRUE
END ELSE BEGIN LOGERR ('param must start with ., +, -, 0..9 or A..Z');OI1O0IO00OO0 := FALSE END END END ;
FUNCTION Ol01Olll10l1 :BOOLEAN ;VAR O10OIO0l0I011:BYTE;BEGIN O10OIO0l0I011 := POS (',', PARSTR );IF O10OIO0l0I011 > 0
THEN BEGIN O1lIlOI11OIO := PARSTR ;BYTE (O1lIlOI11OIO [ 0 ] ):= O10OIO0l0I011 - 1 ;O1lIlOI11OIO := TRIMSTR (O1lIlOI11OIO
);IF O10OIO0l0I011 < BYTE (PARSTR [ 0 ] )THEN BEGIN OOO0lI0llI0l := TRIMSTR (COPY (PARSTR , O10OIO0l0I011 + 1 , BYTE
(PARSTR [ 0 ] )- O10OIO0l0I011 ));Ol01Olll10l1 := TRUE END ELSE BEGIN LOGERR ('right param missing');Ol01Olll10l1 :=
FALSE END END ELSE BEGIN LOGERR ('no , seperator');Ol01Olll10l1 := FALSE END END ;FUNCTION OOlIl10O0OOl :BOOLEAN ;
VAR O10OIIlI0Ill0:BOOLEAN;OO0O:PSCRIPTNODE;OOI1,Ol0O0I1,Ol100OI:PVARNODE;Ol001O0011Ol:PVARASSIGN;OO01:PLABELNODE;
BEGIN O10OIIlI0Ill0 := FINDCOMMAND ;IF O10OIIlI0Ill0 THEN BEGIN CASE CMDNUM  OF CTSCRWAITFOR , CTSCRSEND , CTSCRGETRESP ,
CTSCRCAPAPP , CTSCRCAPNEW , CTSCRSEPCHAR , CTSCRGETCHAR :BEGIN IF OI1001l01l0O THEN BEGIN IF O101I0OOI00OI THEN
BEGIN OOI1 := SCRIPTENG ^. GETVARPTR (PARSTR );IF OOI1 <> NIL THEN BEGIN CASE CMDNUM  OF CTSCRWAITFOR , CTSCRSEND
:O10OIIlI0Ill0 := TRUE ;ELSE O10OIIlI0Ill0 := (OOI1 ^. VARTYPE =CTPSTRING )END ;IF O10OIIlI0Ill0 THEN BEGIN OO0O := NEW
(PSCRIPTNODE , INIT );OO0O ^. SCCOMMAND := CMDNUM ;OO0O ^. SCDATAPTR := OOI1 ;O10OIIlI0Ill0 := SCRIPTENG ^. ADDCOMMAND
(OO0O )END ELSE LOGERR ('var incorrect type '+ PARSTR )END ELSE BEGIN LOGERR ('undefined var '+ PARSTR );O10OIIlI0Ill0 :=
FALSE END END ELSE BEGIN OOI1 := NEW (PVARNODE , INIT );OOI1 ^. VARTYPE := CTPSTRING ;OOI1 ^. VARDATAPTR := NEWSTR
(PARSTR );SCRIPTENG ^. ADDVAR (OOI1 );OO0O := NEW (PSCRIPTNODE , INIT );OO0O ^. SCCOMMAND := CMDNUM ;OO0O ^. SCDATAPTR :=
OOI1 ;O10OIIlI0Ill0 := SCRIPTENG ^. ADDCOMMAND (OO0O )END END ELSE O10OIIlI0Ill0 := FALSE END ;CTSCRIFEQU , CTSCRIFNOTEQU
, CTSCRIFLESS , CTSCRIFGREAT , CTSCRIFLESSEQ , CTSCRIFGREATEQ , CTSCRVARASN , CTSCRVARADD , CTSCRVARSUB , CTSCRVARMUL ,
CTSCRVARDIV :BEGIN IF UPCASE (PARSTR [ 1 ] )IN [ 'A'.. 'Z'] THEN BEGIN IF Ol01Olll10l1 THEN BEGIN OOI1 := SCRIPTENG ^.
GETVARPTR (O1lIlOI11OIO );IF OOI1 <> NIL THEN BEGIN PARSTR := OOO0lI0llI0l ;CASE OOI1 ^. VARTYPE  OF CTPSTRING
:O10OIIlI0Ill0 := OI1001l01l0O ;CTPLONGINT :O10OIIlI0Ill0 := OI0l0I0010IO ;CTPDOUBLE :O10OIIlI0Ill0 := OI1O0IO00OO0 END ;
IF O10OIIlI0Ill0 THEN BEGIN IF O101I0OOI00OI THEN Ol0O0I1 := SCRIPTENG ^. GETVARPTR (PARSTR )ELSE BEGIN Ol0O0I1 := NEW
(PVARNODE , INIT );CASE OOI1 ^. VARTYPE  OF CTPSTRING :BEGIN Ol0O0I1 ^. VARTYPE := CTPSTRING ;Ol0O0I1 ^. VARDATAPTR :=
NEWSTR (PARSTR )END ;CTPLONGINT :BEGIN Ol0O0I1 ^. VARTYPE := CTPLONGINT ;Ol0O0I1 ^. VARDATAPTR := NEW (PLONGINT );
PLONGINT (Ol0O0I1 ^. VARDATAPTR )^:= OIOIll010O0 END ;CTPDOUBLE :BEGIN Ol0O0I1 ^. VARTYPE := CTPDOUBLE ;Ol0O0I1 ^.
VARDATAPTR := NEW (PDOUBLE );PDOUBLE (Ol0O0I1 ^. VARDATAPTR )^:= OI1IO10lI11 END END ;SCRIPTENG ^. ADDVAR (Ol0O0I1 );
END ;IF Ol0O0I1 <> NIL THEN BEGIN O10OIIlI0Ill0 := (OOI1 ^. VARTYPE =Ol0O0I1 ^. VARTYPE );IF O10OIIlI0Ill0 THEN
BEGIN Ol001O0011Ol := NEW (PVARASSIGN );Ol001O0011Ol ^. VARCUR := OOI1 ;Ol001O0011Ol ^. VARNEW := Ol0O0I1 ;Ol100OI := NEW
(PVARNODE , INIT );Ol100OI ^. VARTYPE := CTPVARASSIGN ;Ol100OI ^. VARDATAPTR := Ol001O0011Ol ;SCRIPTENG ^. ADDVAR
(Ol100OI );OO0O := NEW (PSCRIPTNODE , INIT );OO0O ^. SCCOMMAND := CMDNUM ;OO0O ^. SCDATAPTR := Ol100OI ;O10OIIlI0Ill0 :=
SCRIPTENG ^. ADDCOMMAND (OO0O )END ELSE LOGERR ('var incorrect type '+ PARSTR )END ELSE BEGIN LOGERR ('undefined var '+
PARSTR );O10OIIlI0Ill0 := FALSE END END END ELSE BEGIN LOGERR ('undefined var '+ O1lIlOI11OIO );O10OIIlI0Ill0 := FALSE
END END ELSE O10OIIlI0Ill0 := FALSE END ELSE BEGIN LOGERR ('var required');O10OIIlI0Ill0 := FALSE END END ;CTSCRVARSTR ,
CTSCRVARINT , CTSCRVARDBL :BEGIN CASE CMDNUM  OF CTSCRVARSTR :O10OIIlI0Ill0 := OI1001l01l0O ;CTSCRVARINT :O10OIIlI0Ill0
:= OI0l0I0010IO ;CTSCRVARDBL :O10OIIlI0Ill0 := OI1O0IO00OO0 END ;IF O10OIIlI0Ill0 THEN BEGIN IF O101I0OOI00OI THEN
BEGIN IF SCRIPTENG ^. GETVARPTR (PARSTR )=NIL THEN BEGIN OOI1 := NEW (PVARNODE , INIT );CASE CMDNUM  OF CTSCRVARSTR :OOI1
^. VARTYPE := CTPSTRING ;CTSCRVARINT :BEGIN OOI1 ^. VARTYPE := CTPLONGINT ;OOI1 ^. VARDATAPTR := NEW (PLONGINT );END ;
CTSCRVARDBL :BEGIN OOI1 ^. VARTYPE := CTPDOUBLE ;OOI1 ^. VARDATAPTR := NEW (PDOUBLE );END END ;OOI1 ^. VARNAME := NEWSTR
(UPCASESTR (PARSTR ));SCRIPTENG ^. ADDVAR (OOI1 );O10OIIlI0Ill0 := TRUE END ELSE BEGIN LOGERR ('duplicate var name');
O10OIIlI0Ill0 := FALSE END END ELSE BEGIN LOGERR ('var name must start with A..Z');O10OIIlI0Ill0 := FALSE END END END ;
CTSCRGETBLOCK , CTSCRWAITSECS :BEGIN IF OI0l0I0010IO THEN BEGIN IF O101I0OOI00OI THEN BEGIN OOI1 := SCRIPTENG ^.
GETVARPTR (PARSTR );IF OOI1 <> NIL THEN BEGIN IF OOI1 ^. VARTYPE =CTPLONGINT THEN BEGIN OO0O := NEW (PSCRIPTNODE , INIT
);OO0O ^. SCCOMMAND := CMDNUM ;OO0O ^. SCDATAPTR := OOI1 ;O10OIIlI0Ill0 := SCRIPTENG ^. ADDCOMMAND (OO0O )END ELSE
BEGIN LOGERR ('var incorrect type '+ PARSTR );O10OIIlI0Ill0 := FALSE END END ELSE BEGIN LOGERR ('undefined var '+ PARSTR
);O10OIIlI0Ill0 := FALSE END END ELSE BEGIN OOI1 := NEW (PVARNODE , INIT );OOI1 ^. VARTYPE := CTPLONGINT ;OOI1 ^.
VARDATAPTR := NEW (PLONGINT );PLONGINT (OOI1 ^. VARDATAPTR )^:= OIOIll010O0 ;SCRIPTENG ^. ADDVAR (OOI1 );OO0O := NEW
(PSCRIPTNODE , INIT );OO0O ^. SCCOMMAND := CMDNUM ;OO0O ^. SCDATAPTR := OOI1 ;O10OIIlI0Ill0 := SCRIPTENG ^. ADDCOMMAND
(OO0O )END END ELSE O10OIIlI0Ill0 := FALSE END ;CTSCRLABEL :BEGIN IF OI1001l01l0O THEN BEGIN IF O101I0OOI00OI THEN
BEGIN IF GETLABELPTR (PARSTR )=NIL THEN BEGIN OO01 := NEW (PLABELNODE , INIT );OO01 ^. NAME := NEWSTR (UPCASESTR (PARSTR
));OO01 ^. LOC := SCRIPTENG ^. NODECOLLPTR ^. COUNT ;O10OIIlI0Ill0 := ADDLABEL (OO01 )END ELSE BEGIN LOGERR
('duplicate label');O10OIIlI0Ill0 := FALSE END END ELSE BEGIN LOGERR ('label must start with A..Z');O10OIIlI0Ill0 :=
FALSE END END ELSE O10OIIlI0Ill0 := FALSE END ;CTSCRCALL , CTSCRGOTO :BEGIN IF OI1001l01l0O THEN BEGIN IF O101I0OOI00OI
THEN BEGIN OO0O := NEW (PSCRIPTNODE , INIT );OO0O ^. SCCOMMAND := CMDNUM ;O10OIIlI0Ill0 := SCRIPTENG ^. ADDCOMMAND (OO0O
)END ELSE BEGIN LOGERR ('label must start with A..Z');O10OIIlI0Ill0 := FALSE END END ELSE O10OIIlI0Ill0 := FALSE END ;
CTSCRRETURN , CTSCRZMODEMD , CTSCRINIT , CTSCRDIAL , CTSCRHANGUP , CTSCRLOGON , CTSCRLOGOFF , CTSCREND :BEGIN OO0O := NEW
(PSCRIPTNODE , INIT );OO0O ^. SCCOMMAND := CMDNUM ;O10OIIlI0Ill0 := SCRIPTENG ^. ADDCOMMAND (OO0O )END END END ELSE
LOGERR ('invalid command');OOlIl10O0OOl := O10OIIlI0Ill0 END ;BEGIN S := TRIMSTR (S );PARSELINE (S );IF S [ 1 ] <>
';'THEN PASS1 := OOlIl10O0OOl ELSE PASS1 := TRUE END ;FUNCTION TSCRIPTCOMPILE.PASS2 (S:STRING ):BOOLEAN ;
FUNCTION OOlIl10O0OOl :BOOLEAN ;VAR O10OIIlI0Ill0:BOOLEAN;OO0O:PSCRIPTNODE;OOI1:PVARNODE;OO01:PLABELNODE;
BEGIN O10OIIlI0Ill0 := FINDCOMMAND ;CASE CMDNUM  OF CTSCRSEND , CTSCRWAITFOR , CTSCRGETRESP , CTSCRIFEQU , CTSCRIFNOTEQU
, CTSCRIFLESS , CTSCRIFGREAT , CTSCRIFLESSEQ , CTSCRIFGREATEQ , CTSCRVARASN , CTSCRVARADD , CTSCRVARSUB , CTSCRVARMUL ,
CTSCRVARDIV , CTSCRRETURN , CTSCRGETBLOCK , CTSCRWAITSECS , CTSCRCAPAPP , CTSCRCAPNEW , CTSCRZMODEMD , CTSCRSEPCHAR ,
CTSCRGETCHAR , CTSCRINIT , CTSCRDIAL , CTSCRHANGUP , CTSCRLOGON , CTSCRLOGOFF , CTSCREND :BEGIN INC (NODENUM );
O10OIIlI0Ill0 := TRUE END ;CTSCRCALL , CTSCRGOTO :BEGIN OO01 := GETLABELPTR (PARSTR );IF OO01 <> NIL THEN BEGIN OOI1 :=
NEW (PVARNODE , INIT );OOI1 ^. VARTYPE := CTPWORD ;OOI1 ^. VARDATAPTR := NEW (PWORD );PWORD (OOI1 ^. VARDATAPTR )^:= OO01
^. LOC ;SCRIPTENG ^. ADDVAR (OOI1 );OO0O := PSCRIPTNODE (SCRIPTENG ^. NODECOLLPTR ^. AT (NODENUM ));OO0O ^. SCDATAPTR :=
OOI1 ;INC (NODENUM );O10OIIlI0Ill0 := TRUE END ELSE BEGIN LOGERR ('label not found '+ PARSTR );O10OIIlI0Ill0 := FALSE END
END END ;OOlIl10O0OOl := O10OIIlI0Ill0 END ;BEGIN S := TRIMSTR (S );IF S [ 1 ] <> ';'THEN BEGIN PARSELINE (S );PASS2 :=
OOlIl10O0OOl END ELSE PASS2 := TRUE END ;FUNCTION TSCRIPTCOMPILE.COMPILE :BOOLEAN ;VAR OOO10IO101I0:BOOLEAN;
OI11II10l01I:STRING ;OO0O:PSCRIPTNODE;BEGIN PTERMWIN (TWIN )^. UPDATELOG ('Pass 1 '+ EDITWIN ^. EDITOR ^. FILENAME );
OOO10IO101I0 := TRUE ;OI11II10l01I := '';WHILE (GETLINE (OI11II10l01I ))AND (OOO10IO101I0 ) DO BEGIN INC (CURLINE );IF
OI11II10l01I <> ''THEN OOO10IO101I0 := PASS1 (OI11II10l01I )END ;IF OOO10IO101I0 THEN BEGIN OO0O := NEW (PSCRIPTNODE ,
INIT );OO0O ^. SCCOMMAND := CTSCREND ;SCRIPTENG ^. ADDCOMMAND (OO0O );PTERMWIN (TWIN )^. UPDATELOG ('Pass 2 ');CURLINE :=
0 ;CURCHAR := 0 ;LASTCHAR := 0 ;WHILE (GETLINE (OI11II10l01I ))AND (OOO10IO101I0 ) DO BEGIN INC (CURLINE );IF
OI11II10l01I <> ''THEN OOO10IO101I0 := PASS2 (OI11II10l01I )END ;IF OOO10IO101I0 THEN PTERMWIN (TWIN )^. UPDATELOGRAW
(INTTOSTR (CURLINE )+ ' lines, '+ INTTOSTR (SCRIPTENG ^. NODECOLLPTR ^. COUNT )+ ' commands, '+ INTTOSTR (SCRIPTENG ^.
VARCOLLPTR ^. COUNT )+ ' vars', 0 )END ;COMPILE := OOO10IO101I0 END ;CONSTRUCTOR TTERMREC.LOAD (VAR S:TSTREAM);
BEGIN S.READ (NAME , SIZEOF (NAME ));S.READ (PHONENUM , SIZEOF (PHONENUM ));S.READ (DLPATH , SIZEOF (DLPATH ));S.READ
(INITSTR , SIZEOF (INITSTR ));S.READ (COMNAME , SIZEOF (COMNAME ));S.READ (BAUD , SIZEOF (BAUD ));S.READ (PARITY , SIZEOF
(PARITY ));S.READ (DATABITS , SIZEOF (DATABITS ));S.READ (STOPBITS , SIZEOF (STOPBITS ));S.READ (COMOPTIONS , SIZEOF
(COMOPTIONS ));S.READ (TERMOPTS , SIZEOF (TERMOPTS ))END ;PROCEDURE TTERMREC.STORE (VAR S:TSTREAM);BEGIN S.WRITE (NAME ,
SIZEOF (NAME ));S.WRITE (PHONENUM , SIZEOF (PHONENUM ));S.WRITE (DLPATH , SIZEOF (DLPATH ));S.WRITE (INITSTR , SIZEOF
(INITSTR ));S.WRITE (COMNAME , SIZEOF (COMNAME ));S.WRITE (BAUD , SIZEOF (BAUD ));S.WRITE (PARITY , SIZEOF (PARITY ));
S.WRITE (DATABITS , SIZEOF (DATABITS ));S.WRITE (STOPBITS , SIZEOF (STOPBITS ));S.WRITE (COMOPTIONS , SIZEOF (COMOPTIONS
));S.WRITE (TERMOPTS , SIZEOF (TERMOPTS ))END ;CONSTRUCTOR TANSIEMU.INIT (TXTCOLOR:WORD);BEGIN ATTR := TXTCOLOR END ;
PROCEDURE TANSIEMU.PROCESSCHAR (C:CHAR);VAR OIlO:INTEGER;PROCEDURE OI0l1lI0I000 ;BEGIN IF PARAMSTR <> ''THEN INTPARAM [
PARAMINDEX ] := STRTOINT (PARAMSTR )ELSE BEGIN IF (C ='J')OR (C ='K')THEN BEGIN IF ANSIOPTIONS AND CTANSIVT100 <> 0 THEN
INTPARAM [ PARAMINDEX ] := 0 ELSE INTPARAM [ PARAMINDEX ] := 2 END ELSE INTPARAM [ PARAMINDEX ] := 1 END END ;
BEGIN ANSICHR := C ;IF ANSIOPTIONS AND CTANSIPARAMS =0 THEN BEGIN CASE ANSICHR  OF CTESC :IF ANSIOPTIONS AND CTANSIESC =0
THEN BEGIN ANSIOPTIONS := ANSIOPTIONS OR CTANSIESC ;ANSICMD := CTEMUNONE END ELSE BEGIN ANSIOPTIONS := ANSIOPTIONS AND
NOT CTANSIESC ;ANSICMD := CTEMUERROR END ;CTLEFTBRACK :BEGIN IF ANSIOPTIONS AND CTANSIESC <> 0 THEN BEGIN PARAMSTR := '';
PARAMINDEX := 0 ;ANSIOPTIONS := (ANSIOPTIONS AND NOT CTANSIESC )OR CTANSIPARAMS ;ANSICMD := CTEMUNONE END ELSE ANSICMD :=
CTEMUCHAR END ;CTFF :BEGIN IF ANSIOPTIONS AND CTANSIESC =0 THEN ANSICMD := CTEMUCLRSCR ELSE ANSICMD := CTEMUERROR END
ELSE ANSICMD := CTEMUCHAR END END ELSE BEGIN IF ANSIOPTIONS AND CTANSIKEYSTR =0 THEN BEGIN CASE ANSICHR  OF ';':BEGIN IF
PARAMINDEX <= CTANSIINTMAX THEN BEGIN IF PARAMSTR <> ''THEN BEGIN INTPARAM [ PARAMINDEX ] := STRTOINT (PARAMSTR );INC
(PARAMINDEX );PARAMSTR := '';ANSICMD := CTEMUNONE END END ELSE ANSICMD := CTEMUERROR END ;'m':BEGIN OI0l1lI0I000 ;X :=
ATTR ;FOR OIlO := 0 TO PARAMINDEX  DO BEGIN IF ANSIOPTIONS AND CTANSIINVERSE <> 0 THEN BEGIN X := X AND $77 ;X := (X SHL
4 )OR (X SHR 4 )END ;CASE INTPARAM [ OIlO ]  OF 0 :BEGIN X := $07 ;ANSIOPTIONS := ANSIOPTIONS AND NOT CTANSIATTR END ;1 ,
4 :ANSIOPTIONS := ANSIOPTIONS OR CTANSIINTENSE ;2 , 22 , 24 :ANSIOPTIONS := ANSIOPTIONS AND NOT CTANSIINTENSE ;5
:ANSIOPTIONS := ANSIOPTIONS OR CTANSIBLINK ;7 :ANSIOPTIONS := ANSIOPTIONS OR CTANSIINVERSE ;8 :ANSIOPTIONS := ANSIOPTIONS
OR CTANSIINVIS ;25 :ANSIOPTIONS := ANSIOPTIONS AND NOT CTANSIBLINK ;27 :ANSIOPTIONS := ANSIOPTIONS AND NOT CTANSIINVERSE
;30 :X := (X AND $f8 )OR $00 ;31 :X := (X AND $f8 )OR $04 ;32 :X := (X AND $f8 )OR $02 ;33 :X := (X AND $f8 )OR $06 ;34
:X := (X AND $f8 )OR $01 ;35 :X := (X AND $f8 )OR $05 ;36 :X := (X AND $f8 )OR $03 ;37 :X := (X AND $f8 )OR $07 ;40 :X :=
(X AND $8f )OR $00 ;41 :X := (X AND $8f )OR $40 ;42 :X := (X AND $8f )OR $20 ;43 :X := (X AND $8f )OR $60 ;44 :X := (X
AND $8f )OR $10 ;45 :X := (X AND $8f )OR $50 ;46 :X := (X AND $8f )OR $30 ;47 :X := (X AND $8f )OR $70 ;END END ;IF
ANSIOPTIONS AND CTANSIINVERSE <> 0 THEN X := (X SHL 4 )OR (X SHR 4 );IF ANSIOPTIONS AND CTANSIINVIS <> 0 THEN X := $00 ;
IF ANSIOPTIONS AND CTANSIINTENSE <> 0 THEN X := X OR $08 ;IF ANSIOPTIONS AND CTANSIBLINK <> 0 THEN X := X OR $80 ;ATTR :=
X ;ANSICMD := CTEMUSETATTR END ;'f', 'H':BEGIN OI0l1lI0I000 ;Y := INTPARAM [ 0 ] ;X := INTPARAM [ 1 ] ;ANSICMD :=
CTEMUGOTOXY END ;'A':BEGIN OI0l1lI0I000 ;Y := INTPARAM [ 0 ] ;ANSICMD := CTEMUUP END ;'B':BEGIN OI0l1lI0I000 ;Y :=
INTPARAM [ 0 ] ;ANSICMD := CTEMUDOWN END ;'C':BEGIN OI0l1lI0I000 ;X := INTPARAM [ 0 ] ;ANSICMD := CTEMURIGHT END ;
'D':BEGIN OI0l1lI0I000 ;X := INTPARAM [ 0 ] ;ANSICMD := CTEMULEFT END ;'J':BEGIN OI0l1lI0I000 ;CASE INTPARAM [ 0 ]  OF 0
:ANSICMD := CTEMUCLRBELOW ;1 :ANSICMD := CTEMUCLRABOVE ;2 :ANSICMD := CTEMUCLRSCR ELSE ANSICMD := CTEMUERROR END END ;
'K':BEGIN OI0l1lI0I000 ;CASE INTPARAM [ 0 ]  OF 0 :ANSICMD := CTEMUCLRENDLINE ;1 :ANSICMD := CTEMUCLRSTARTLINE ;2
:ANSICMD := CTEMUCLRLINE ELSE ANSICMD := CTEMUERROR END END ;'=', '?':ANSICMD := CTEMUNONE ;'h':BEGIN OI0l1lI0I000 ;X :=
INTPARAM [ 0 ] ;ANSICMD := CTEMUSETMODE END ;'l':BEGIN OI0l1lI0I000 ;X := INTPARAM [ 0 ] ;ANSICMD := CTEMURESETMODE END ;
's':ANSICMD := CTEMUSAVECURPOS ;'u':ANSICMD := CTEMURESCURPOS ;'n':ANSICMD := CTEMUDEVSTATREP ;'L':ANSICMD :=
CTEMUINSLINE ;'M':ANSICMD := CTEMUDELLINE ;'@':ANSICMD := CTEMUINSCHAR ;'P':ANSICMD := CTEMUDELCHAR ;
'p':BEGIN OI0l1lI0I000 ;X := INTPARAM [ 0 ] ;ANSICMD := CTEMUKEYREMAP END ;'"':BEGIN ANSIOPTIONS := ANSIOPTIONS OR
CTANSIKEYSTR ;ANSICMD := CTEMUNONE END ELSE IF BYTE (PARAMSTR [ 0 ] )< CTANSISTRMAX THEN BEGIN PARAMSTR := PARAMSTR +
ANSICHR ;ANSICMD := CTEMUNONE END ELSE ANSICMD := CTEMUERROR END ;IF ANSICMD <> CTEMUNONE THEN ANSIOPTIONS := ANSIOPTIONS
AND NOT CTANSIPARAMS END ELSE BEGIN IF BYTE (PARAMSTR [ 0 ] )< CTANSISTRMAX THEN BEGIN IF ANSICHR <> '"'THEN PARAMSTR :=
PARAMSTR + ANSICHR ELSE BEGIN KEYSTR := PARAMSTR ;PARAMSTR := '';ANSIOPTIONS := ANSIOPTIONS AND NOT CTANSIKEYSTR END ;
ANSICMD := CTEMUNONE END ELSE BEGIN ANSIOPTIONS := ANSIOPTIONS AND NOT (CTANSIKEYSTR OR CTANSIPARAMS );ANSICMD :=
CTEMUERROR END END END END ;CONSTRUCTOR TANSITERM.INIT (VAR BOUNDS:TRECT;AHSCROLLBAR,AVSCROLLBAR:PSCROLLBAR;
GENOPTSPTR:PTERMGENOPTSREC;APORT:CTUARTPORTPTR);VAR OIlO:INTEGER;BEGIN INHERITED INIT(BOUNDS , AHSCROLLBAR , AVSCROLLBAR
);GROWMODE := GFGROWHIX + GFGROWHIY ;MAXBUFCHARS := GENOPTSPTR ^. TERMDRAW ;LINELEN := GENOPTSPTR ^. TERMWIDTH - 1 ;
LINES := GENOPTSPTR ^. TERMLEN - 1 ;LINESIZE := (LINELEN + 1 )* SIZEOF (WORD );DRAWBUF := MEMALLOC ((LINES + 1 )* SIZEOF
(CTLINEBUFPTR ));FOR OIlO := 0 TO LINES  DO DRAWBUF ^[ OIlO ] := MEMALLOC (LINESIZE );ANSIEMU.INIT (HI (CTCHARCOLOR ));
UPORTPTR := APORT ;DRAWCOLOR := CTCHARCOLOR ;SETLIMIT (LINELEN + 1 , LINES + 1 );IF DRAWBUF ^[ LINES ] <> NIL THEN
CLEARSCR END ;DESTRUCTOR TANSITERM.DONE ;VAR OIlO:INTEGER;BEGIN IF DRAWBUF <> NIL THEN BEGIN FOR OIlO := 0 TO LINES
 DO IF DRAWBUF ^[ OIlO ] <> NIL THEN FREEMEM (DRAWBUF ^[ OIlO ] , LINESIZE );IF DRAWBUF <> NIL THEN FREEMEM (DRAWBUF ,
(LINES + 1 )* SIZEOF (CTLINEBUFPTR ))END ;INHERITED DONE END ;PROCEDURE TANSITERM.DRAW ;VAR OOIl:INTEGER;BEGIN FOR OOIl :=
0 TO SIZE.Y - 1  DO WRITEBUF (0 , OOIl , SIZE.X , 1 , DRAWBUF ^[ DELTA.Y + OOIl ] ^[ DELTA.X ] );SETCURSOR (XBUF -
DELTA.X , YBUF - DELTA.Y );SHOWCURSOR END ;PROCEDURE TANSITERM.ADJUSTBUFFER ;VAR OIlO:INTEGER;OIOI:WORD;BEGIN IF XBUF >
LINELEN THEN BEGIN XBUF := 0 ;INC (YBUF )END ;IF YBUF > LINES THEN BEGIN FOR OIlO := 1 TO LINES  DO MOVE (DRAWBUF ^[ OIlO
] ^[ 0 ] , DRAWBUF ^[ OIlO - 1 ] ^[ 0 ] , LINESIZE );OIOI := DRAWCOLOR OR BYTE (CTSP );FOR OIlO := 0 TO LINELEN
 DO DRAWBUF ^[ LINES ] ^[ OIlO ] := OIOI ;YBUF := LINES END END ;PROCEDURE TANSITERM.TRACKCURSOR ;VAR OOIO,OOIl:INTEGER;
BEGIN IF YBUF - DELTA.Y >= SIZE.Y THEN OOIl := YBUF - SIZE.Y + 1 ELSE IF YBUF < DELTA.Y THEN OOIl := YBUF ELSE OOIl :=
DELTA.Y ;IF XBUF - DELTA.X >= SIZE.X THEN OOIO := XBUF - SIZE.X + 1 ELSE IF XBUF < DELTA.X THEN OOIO := XBUF ELSE OOIO :=
DELTA.X ;IF (OOIl <> DELTA.Y )OR (OOIO <> DELTA.X )THEN SCROLLTO (OOIO , OOIl )END ;PROCEDURE TANSITERM.PUTVIEWCHAR ;
BEGIN CASE ANSIEMU.ANSICHR  OF CTCR :XBUF := 0 ;CTLF :INC (YBUF );CTBS :IF XBUF > 0 THEN DEC (XBUF );CTBELL :;ELSE
BEGIN DRAWBUF ^[ YBUF ] ^[ XBUF ] := DRAWCOLOR OR BYTE (ANSIEMU.ANSICHR );INC (XBUF )END END ;INC (BUFCHARS );
ADJUSTBUFFER END ;PROCEDURE TANSITERM.SETATTR ;BEGIN DRAWCOLOR := ANSIEMU.X SHL 8 END ;PROCEDURE TANSITERM.SETBUFXY ;
BEGIN IF ANSIEMU.X - 1 <= LINELEN THEN XBUF := ANSIEMU.X - 1 ELSE XBUF := LINELEN ;IF ANSIEMU.Y - 1 <= LINES THEN YBUF :=
ANSIEMU.Y - 1 ELSE YBUF := LINES ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.CLEARSCR ;VAR OOIO,OOIl:INTEGER;OIOI:WORD;
BEGIN OIOI := DRAWCOLOR OR BYTE (CTSP );FOR OOIl := 0 TO LINES  DO FOR OOIO := 0 TO LINELEN  DO DRAWBUF ^[ OOIl ] ^[ OOIO
] := OIOI ;XBUF := 0 ;YBUF := 0 ;TRACKCURSOR ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.CLEARBELOW ;VAR OOIO,OOIl:INTEGER;
OIOI:WORD;BEGIN OIOI := DRAWCOLOR OR BYTE (CTSP );FOR OOIl := YBUF TO LINES  DO FOR OOIO := 0 TO LINELEN  DO DRAWBUF ^[
OOIl ] ^[ OOIO ] := OIOI ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.CLEARABOVE ;VAR OOIO,OOIl:INTEGER;OIOI:WORD;BEGIN OIOI
:= DRAWCOLOR OR BYTE (CTSP );FOR OOIl := 0 TO YBUF  DO FOR OOIO := 0 TO LINELEN  DO DRAWBUF ^[ OOIl ] ^[ OOIO ] := OIOI ;
INC (BUFCHARS )END ;PROCEDURE TANSITERM.CLEAREOL ;VAR OOIO:INTEGER;OIOI:WORD;BEGIN OIOI := DRAWCOLOR OR BYTE (CTSP );
FOR OOIO := XBUF TO LINELEN  DO DRAWBUF ^[ YBUF ] ^[ OOIO ] := OIOI ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.CLEARSOL ;
VAR OOIO:INTEGER;OIOI:WORD;BEGIN OIOI := DRAWCOLOR OR BYTE (CTSP );FOR OOIO := 0 TO XBUF  DO DRAWBUF ^[ YBUF ] ^[ OOIO ]
:= OIOI ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.CLEARLINE ;VAR OOIO:INTEGER;OIOI:WORD;BEGIN OIOI := DRAWCOLOR OR BYTE
(CTSP );FOR OOIO := 0 TO LINELEN  DO DRAWBUF ^[ YBUF ] ^[ OOIO ] := OIOI ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.UP ;
VAR OOIl:INTEGER;BEGIN OOIl := YBUF - ANSIEMU.Y ;IF OOIl >= 0 THEN YBUF := OOIl ELSE YBUF := 0 ;INC (BUFCHARS )END ;
PROCEDURE TANSITERM.DOWN ;VAR OOIl:INTEGER;BEGIN OOIl := YBUF + ANSIEMU.Y ;IF OOIl <= LINES THEN YBUF := OOIl ELSE YBUF
:= LINES ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.LEFT ;VAR OOIO:INTEGER;BEGIN OOIO := XBUF - ANSIEMU.X ;IF OOIO >= 0
THEN XBUF := OOIO ELSE XBUF := 0 ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.RIGHT ;VAR OOIO:INTEGER;BEGIN OOIO := XBUF +
ANSIEMU.X ;IF OOIO <= LINELEN THEN XBUF := OOIO ELSE XBUF := LINELEN ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.SAVECURPOS
;BEGIN SAVECURX := XBUF ;SAVECURY := YBUF ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.RESTORECURPOS ;BEGIN XBUF := SAVECURX
;YBUF := SAVECURY ;INC (BUFCHARS )END ;PROCEDURE TANSITERM.DEVICESTATUS ;VAR OOO0OOl0IlIO:STRING ;BEGIN OOO0OOl0IlIO :=
CTESC + '['+ INTTOSTR (YBUF - DELTA.Y + 1 )+ ';'+ INTTOSTR (XBUF - DELTA.X + 1 )+ 'R';UPORTPTR ^. PUTSTRING (OOO0OOl0IlIO
);PTERMWIN (OWNER )^. UPDATELOG ('Sending ANSI device status '+ OOO0OOl0IlIO )END ;PROCEDURE TANSITERM.PROCANSICHAR
(C:CHAR);BEGIN ANSIEMU.PROCESSCHAR (C );CASE ANSIEMU.ANSICMD  OF CTEMUNONE :BEGIN IF (TERMOPTIONS AND CTRAWCAP <> 0 )AND
(PTERMWIN (OWNER )^. CAPTUREON )THEN {$I-}WRITE (PTERMWIN (OWNER )^. CAPFILE , C ){$I+}END ;CTEMUCHAR :BEGIN PUTVIEWCHAR
;IF PTERMWIN (OWNER )^. CAPTUREON THEN {$I-}WRITE (PTERMWIN (OWNER )^. CAPFILE , C ){$I+}END ;CTEMUGOTOXY :SETBUFXY ;
CTEMUUP :UP ;CTEMUDOWN :DOWN ;CTEMURIGHT :RIGHT ;CTEMULEFT :LEFT ;CTEMUSETATTR :SETATTR ;CTEMUCLRSCR :CLEARSCR ;
CTEMUCLRBELOW :CLEARBELOW ;CTEMUCLRABOVE :CLEARABOVE ;CTEMUCLRENDLINE :CLEAREOL ;CTEMUCLRSTARTLINE :CLEARSOL ;
CTEMUCLRLINE :CLEARLINE ;CTEMUSAVECURPOS :SAVECURPOS ;CTEMURESCURPOS :RESTORECURPOS ;CTEMUDEVSTATREP :DEVICESTATUS END
END ;PROCEDURE TANSITERM.PROCINBUF ;VAR OIOI:CHAR;BEGIN WHILE (UPORTPTR ^. CHARREADY )AND (MAXBUFCHARS > BUFCHARS
) DO BEGIN UPORTPTR ^. GETCHAR (OIOI );PROCANSICHAR (OIOI )END ;IF BUFCHARS > 0 THEN BEGIN IF NOT UPORTPTR ^. CHARREADY
THEN TRACKCURSOR ;DRAWVIEW ;BUFCHARS := 0 END END ;PROCEDURE TANSITERM.HANDLEEVENT (VAR EVENT:TEVENT);
BEGIN INHERITED HANDLEEVENT(EVENT );IF (EVENT.WHAT =EVKEYDOWN )AND (PTERMWIN (OWNER )^. CMDSTATE =0 )THEN BEGIN IF
EVENT.CHARCODE <> #0THEN UPORTPTR ^. PUTSTRING (EVENT.CHARCODE )ELSE CASE EVENT.KEYCODE  OF KBUP :UPORTPTR ^. PUTSTRING
(CTESC + '[A');KBDOWN :UPORTPTR ^. PUTSTRING (CTESC + '[B');KBLEFT :UPORTPTR ^. PUTSTRING (CTESC + '[D');KBRIGHT
:UPORTPTR ^. PUTSTRING (CTESC + '[C')ELSE EXIT END ;CLEAREVENT (EVENT )END END ;CONSTRUCTOR TTERMWIN.INIT
(WINTITLE:TTITLESTR;TERMRECPTR:PTERMREC;GENOPTSPTR:PTERMGENOPTSREC);VAR OO1I:TRECT;OOIOI1II000O,OOIOI1II00l1:PSCROLLBAR;
BEGIN DESKTOP ^. GETEXTENT (OO1I );OO1I.B.Y := OO1I.B.Y - 7 ;INHERITED INIT(OO1I , WINTITLE );OPTIONS := OPTIONS OR
OFTILEABLE ;FLAGS := WFMOVE + WFGROW + WFCLOSE + WFZOOM ;GROWMODE := GFGROWREL ;PALETTE := DPBLUEDIALOG ;OOIOI1II000O :=
STANDARDSCROLLBAR (SBHORIZONTAL OR SBHANDLEKEYBOARD );INSERT (OOIOI1II000O );OOIOI1II00l1 := STANDARDSCROLLBAR
(SBVERTICAL OR SBHANDLEKEYBOARD );INSERT (OOIOI1II00l1 );CAPTUREON := FALSE ;TERMREC := TERMRECPTR ;GENOPTSREC :=
GENOPTSPTR ;REDIALCNT := GENOPTSREC ^. REDIAL ;WITH TERMREC^ DO BEGIN UPORT.INITCUSTOM (COMNAME , BAUD , PARITY ,
DATABITS , STOPBITS , GENOPTSREC ^. INBUF , GENOPTSREC ^. OUTBUF , COMOPTIONS );IF GETASYNCSTATUS =ECOK THEN
BEGIN UPORT.UARTWIN := @ SELF ;UPORT.SETWAITCHARPROC (OOII1O0l0I1I );UPDATELOG ('Opening port ');IF TERMOPTS AND
CTHARDFLOW <> 0 THEN UPORT.HWFLOWENABLE (GENOPTSREC ^. INBUF - (GENOPTSREC ^. INBUF DIV 10 ), GENOPTSREC ^. INBUF DIV 10
, TERMOPTS AND CTHARDFLOW )ELSE UPORT.HWFLOWDISABLE ;IF TERMOPTS AND CTXONXOFF <> 0 THEN UPORT.SWFLOWENABLE (GENOPTSREC
^. INBUF - (GENOPTSREC ^. INBUF SHR 2 ), GENOPTSREC ^. INBUF SHR 2 )ELSE UPORT.SWFLOWDISABLE ;IF TERMOPTS AND CTFIFO <> 0
THEN BEGIN IF CLASSIFYUART (UPORT.GETBASEADDR , FALSE )=U16550A THEN BEGIN SETFIFOBUFFERING (UPORT.GETBASEADDR , TRUE , 4
);UPDATELOG ('16550A UART FIFO buffering on')END ELSE UPDATELOG (UARTTYPESTRING [ CLASSIFYUART (UPORT.GETBASEADDR , FALSE
)] + ' UART does not support FIFO buffering')END ;GETEXTENT (OO1I );OO1I.GROW (- 1 , - 1 );NEW (TERM , INIT (OO1I ,
OOIOI1II000O , OOIOI1II00l1 , GENOPTSPTR , @ UPORT ));TERM ^. TERMOPTIONS := TERMOPTS ;IF TERMOPTS AND CTVT100 <> 0 THEN
TERM ^. ANSIEMU.ANSIOPTIONS := TERM ^. ANSIEMU.ANSIOPTIONS OR CTANSIVT100 ;IF APPLICATION ^. VALIDVIEW (TERM )<> NIL THEN
INSERT (TERM );WITH GENOPTSPTR^ DO BEGIN RESPWAITSTR := RESPCONNECT + CTSEPCHAR + RESPERROR + CTSEPCHAR + RESPNOCARR +
CTSEPCHAR + RESPNOANS + CTSEPCHAR + RESPNOTONE + CTSEPCHAR + RESPBUSY ;OKSTR := RESPOK + CTSEPCHAR + RESPERROR END END
END END ;DESTRUCTOR TTERMWIN.DONE ;BEGIN IF SCRIPTENG <> NIL THEN DISPOSE (SCRIPTENG , DONE );CAPTURECLOSE ;UPDATELOG
('Closing port, '+ STATUSSTR (GETASYNCSTATUS ));UPORT.DONE ;INHERITED DONE END ;PROCEDURE TTERMWIN.WAITCTSLOW ;BEGIN IF
CMDSTATE AND CTCMDCTSLOW <> 0 THEN BEGIN IF NOT TIMEREXPIRED (TERMTIMER )THEN BEGIN IF UPORT.CHECKCTS THEN CMDSTATE :=
CMDSTATE AND NOT (CTCMDCTSWAIT OR CTCMDCTSLOW )END ELSE BEGIN UPDATELOG ('CTS time out');CLOSE END END ELSE
BEGIN NEWTIMERSECS (TERMTIMER , GENOPTSREC ^. WAITCTS );CMDSTATE := CMDSTATE OR CTCMDCTSLOW END END ;
PROCEDURE TTERMWIN.HANGUP ;BEGIN IF CMDSTATE AND (CTCMDDIALPAUSE OR CTCMDDIAL )=0 THEN BEGIN IF CMDSTATE AND CTCMDDTRLOW
<> 0 THEN BEGIN IF TIMEREXPIRED (TERMTIMER )THEN BEGIN UPORT.SETDTR (TRUE );CMDSTATE := CMDSTATE AND NOT (CTCMDHANGUP OR
CTCMDDTRLOW )END END ELSE BEGIN UPORT.SETDTR (FALSE );CMDSTATE := CMDSTATE OR CTCMDDTRLOW ;NEWTIMERSECS (TERMTIMER ,
GENOPTSREC ^. WAITDTR )END END ELSE BEGIN UPORT.FLUSHOUTBUFFER ;UPORT.PUTCHAR (GENOPTSREC ^. CANCELCHAR );CMDSTATE :=
CMDSTATE AND NOT (CTCMDHANGUP OR CTCMDDIAL OR CTCMDRESPWAIT OR CTCMDRESPREC OR CTCMDRESPTIME )END END ;
FUNCTION TTERMWIN.FINDLOGWIN :PLOGWIN ;FUNCTION O1OOOlOlII1l (OO10:PVIEW):BOOLEAN ;FAR ;BEGIN O1OOOlOlII1l := (TYPEOF
(OO10 ^)=TYPEOF (TLOGWIN ))END ;BEGIN FINDLOGWIN := PLOGWIN (DESKTOP ^. FIRSTTHAT (@ O1OOOlOlII1l ))END ;
PROCEDURE TTERMWIN.UPDATELOG (S:STRING );VAR OIlO:WORD;Ol00O010IlI1:TEXTBUF;OI1ll0I1l11:PLOGWIN;BEGIN OI1ll0I1l11 :=
FINDLOGWIN ;IF (OI1ll0I1l11 <> NIL )AND (BYTE (S [ 0 ] )> 0 )THEN BEGIN FOR OIlO := 1 TO BYTE (S [ 0 ] ) DO IF S [ OIlO ]
=CTLF THEN BEGIN SYSTEM.DELETE (S , OIlO , 1 );SYSTEM.INSERT ('[LF]', S , OIlO )END ELSE IF S [ OIlO ] =CTCR THEN
BEGIN SYSTEM.DELETE (S , OIlO , 1 );SYSTEM.INSERT ('[CR]', S , OIlO )END ;S := CTLF + TIMESTR + ' '+ COMNAMESTRING
(TERMREC ^. COMNAME )+ ' '+ S ;MOVE (S [ 1 ] , Ol00O010IlI1 [ 0 ] , BYTE (S [ 0 ] ));OI1ll0I1l11 ^. LOGTERM ^. STRWRITE
(Ol00O010IlI1 , BYTE (S [ 0 ] ))END END ;PROCEDURE TTERMWIN.UPDATELOGRAW (S:STRING ;POSQUE:WORD);VAR OIlO:WORD;
Ol00O010IlI1:TEXTBUF;OI1ll0I1l11:PLOGWIN;BEGIN OI1ll0I1l11 := FINDLOGWIN ;IF (OI1ll0I1l11 <> NIL )AND (BYTE (S [ 0 ] )> 0
)THEN BEGIN FOR OIlO := 1 TO BYTE (S [ 0 ] ) DO IF S [ OIlO ] =CTLF THEN BEGIN SYSTEM.DELETE (S , OIlO , 1 );
SYSTEM.INSERT ('[LF]', S , OIlO )END ELSE IF S [ OIlO ] =CTCR THEN BEGIN SYSTEM.DELETE (S , OIlO , 1 );SYSTEM.INSERT
('[CR]', S , OIlO )END ;MOVE (S [ 1 ] , Ol00O010IlI1 [ 0 ] , BYTE (S [ 0 ] ));OI1ll0I1l11 ^. LOGTERM ^. STRWRITE
(Ol00O010IlI1 , BYTE (S [ 0 ] ));IF POSQUE > 0 THEN DEC (OI1ll0I1l11 ^. LOGTERM ^. QUEFRONT , POSQUE )END END ;
PROCEDURE TTERMWIN.GETRESP ;BEGIN IF NOT TIMEREXPIRED (TERMTIMER )THEN BEGIN UPORT.SCANFORMULTISTRING (RESPWAITSTR ,
CTSEPCHAR , RESPSTR , RESPFOUND );IF RESPFOUND > 0 THEN BEGIN UPORT.WAITFORSTRING (#10, 0 );CMDSTATE := (CMDSTATE AND NOT
CTCMDRESPWAIT )OR CTCMDRESPREC END END ELSE CMDSTATE := (CMDSTATE AND NOT CTCMDRESPWAIT )OR CTCMDRESPTIME END ;
PROCEDURE TTERMWIN.PUTCMD (CMD,RESP:STRING ;RSECS:WORD);BEGIN UPORT.FLUSHOUTBUFFER ;UPORT.PUTSTRING (CMD + CTCR );
CMDSTATE := CMDSTATE OR CTCMDRESPWAIT ;RESPSTR := '';RESPWAITSTR := RESP ;NEWTIMERSECS (TERMTIMER , RSECS )END ;
PROCEDURE TTERMWIN.INITXFER ;VAR OIlOIOO0110:LONGINT;OI1IIl1Il0Il:PARITYTYPE;OOI10000000l:DATABITTYPE;
O101O1llOOII1:STOPBITTYPE;PROCEDURE O1OlOIlIOIOI (OI1000l1II00:POINTER);FAR ;BEGIN FILELISTSIZE := FILELISTSIZE + BYTE
(PSTRING (OI1000l1II00 )^[ 0 ] )+ 1 END ;PROCEDURE O10100l1lIO0O (OI1000l1II00:POINTER);FAR ;BEGIN PROTOCOL ^.
ADDFILETOLIST (UPLOADLIST , PSTRING (OI1000l1II00 )^)END ;BEGIN IF CMDSTATE AND CTCMDDOWNLOAD <> 0 THEN UPDATELOG
(PROTOCOLTYPESTRING [ PROTOCOLNUM ] + ' down load start')ELSE UPDATELOG (PROTOCOLTYPESTRING [ PROTOCOLNUM ] +
' up load start');CASE PROTOCOLNUM  OF ASCII :BEGIN NEW (CTASCIIPROTOCOLPTR (PROTOCOL ), INIT (@ UPORT ));
CTASCIIPROTOCOLPTR (PROTOCOL )^. PROTWIN := @ SELF END ;KERMIT :BEGIN NEW (CTKERMITPROTOCOLPTR (PROTOCOL ), INIT (@ UPORT
));CTKERMITPROTOCOLPTR (PROTOCOL )^. PROTWIN := @ SELF ;CTKERMITPROTOCOLPTR (PROTOCOL )^. SETOVERWRITEOPTION (WRITEANYWAY
)END ;XMODEM :BEGIN NEW (CTXMODEMPROTOCOLPTR (PROTOCOL ), INIT (@ UPORT , FALSE , FALSE ));CTXMODEMPROTOCOLPTR (PROTOCOL
)^. PROTWIN := @ SELF END ;XMODEM1K :BEGIN NEW (CTXMODEMPROTOCOLPTR (PROTOCOL ), INIT (@ UPORT , TRUE , FALSE ));
CTXMODEMPROTOCOLPTR (PROTOCOL )^. PROTWIN := @ SELF END ;XMODEM1KG :BEGIN NEW (CTXMODEMPROTOCOLPTR (PROTOCOL ), INIT (@
UPORT , TRUE , TRUE ));CTXMODEMPROTOCOLPTR (PROTOCOL )^. PROTWIN := @ SELF END ;YMODEM :BEGIN NEW (CTYMODEMPROTOCOLPTR
(PROTOCOL ), INIT (@ UPORT , TRUE , FALSE ));CTYMODEMPROTOCOLPTR (PROTOCOL )^. PROTWIN := @ SELF END ;YMODEMG :BEGIN NEW
(CTYMODEMPROTOCOLPTR (PROTOCOL ), INIT (@ UPORT , TRUE , TRUE ));CTYMODEMPROTOCOLPTR (PROTOCOL )^. PROTWIN := @ SELF END
;ZMODEM :BEGIN NEW (CTZMODEMPROTOCOLPTR (PROTOCOL ), INIT (@ UPORT ));CTZMODEMPROTOCOLPTR (PROTOCOL )^. PROTWIN := @ SELF
;IF CMDSTATE AND CTCMDDOWNLOAD <> 0 THEN CTZMODEMPROTOCOLPTR (PROTOCOL )^. SETFILEMGMTOPTIONS (TRUE , FALSE ,
WRITECLOBBER )ELSE CTZMODEMPROTOCOLPTR (PROTOCOL )^. SETFILEMGMTOPTIONS (FALSE , FALSE , WRITECLOBBER )END END ;PROTOCOL
^. SETLOGFILEPROC (O10O11O1l101I );IF PROTOCOLNUM IN [ XMODEM .. YMODEMG ] THEN
WITH CTXMODEMPROTOCOLPTR(PROTOCOL)^ DO BEGIN SETBLOCKWAIT (RELAXEDBLOCKWAIT );SETHANDSHAKEWAIT (DEFHANDSHAKEWAIT , 0 );
SETOVERWRITEOPTION (WRITEANYWAY )END ;IF CMDSTATE AND CTCMDDOWNLOAD <> 0 THEN BEGIN IF PROTOCOLNUM IN [ XMODEM ..
XMODEM1KG , ASCII ] THEN PROTOCOL ^. SETRECEIVEFILENAME (PSTRING (FILELISTCOLL ^. AT (0 ))^)ELSE PROTOCOL ^.
SETDESTINATIONDIRECTORY (TERMREC ^. DLPATH );PROTOCOL ^. PREPARERECEIVEPART END ELSE BEGIN FILELISTSIZE := 0 ;
FILELISTCOLL ^. FOREACH (@ O1OlOIlIOIOI );INC (FILELISTSIZE );PROTOCOL ^. MAKEFILELIST (UPLOADLIST , FILELISTSIZE );
FILELISTCOLL ^. FOREACH (@ O10100l1lIO0O );PROTOCOL ^. SETFILELIST (UPLOADLIST );PROTOCOL ^. SETNEXTFILEFUNC
(NEXTFILELIST );PROTOCOL ^. PREPARETRANSMITPART END ;UPORT.GETLINE (OIlOIOO0110 , OI1IIl1Il0Il , OOI10000000l ,
O101O1llOOII1 , TRUE );PROTOCOL ^. SETACTUALBPS (OIlOIOO0110 );NEWTIMERSECS (TERMTIMER , CTXFERLOGWAIT );CMDSTATE :=
(CMDSTATE AND NOT CTCMDXFERINIT )OR CTCMDXFER END ;FUNCTION TTERMWIN.XFERSTATUSSTR :STRING ;
VAR O10O0Il1Ill01,OOIlI1O00I1l:LONGINT;BEGIN O10O0Il1Ill01 := TICS2SECS (PROTOCOL ^. GETELAPSEDTICS );IF (PROTOCOL ^.
BYTESTRANSFERRED > 0 )AND (O10O0Il1Ill01 > 0 )THEN OOIlI1O00I1l := PROTOCOL ^. BYTESTRANSFERRED DIV O10O0Il1Ill01 ELSE
OOIlI1O00I1l := 0 ;XFERSTATUSSTR := PADRIGHTSTR (PROTOCOL ^. GETFILENAME , ' ', 12 )+ INTTORIGHTSTR (PROTOCOL ^.
BYTESTRANSFERRED , 10 )+ INTTORIGHTSTR (OOIlI1O00I1l , 7 )+ INTTORIGHTSTR (PROTOCOL ^. GETTOTALERRORS , 4 )END ;
PROCEDURE TTERMWIN.XFERTASK ;VAR OOIllIO00O0I:STRING ;BEGIN IF CMDSTATE AND CTCMDDOWNLOAD <> 0 THEN BEGIN IF PROTOCOL ^.
PROTOCOLRECEIVEPART =PSFINISHED THEN BEGIN UPDATELOG (STATUSSTR (GETASYNCSTATUS ));UPDATELOG (PROTOCOLTYPESTRING [
PROTOCOLNUM ] + ' down load end');DISPOSE (PROTOCOL , DONE );CMDSTATE := CMDSTATE AND NOT (CTCMDDOWNLOAD OR CTCMDXFER OR
CTCMDXFERSTAT )END END ELSE BEGIN IF PROTOCOL ^. PROTOCOLTRANSMITPART =PSFINISHED THEN BEGIN UPDATELOG (STATUSSTR
(GETASYNCSTATUS ));UPDATELOG (PROTOCOLTYPESTRING [ PROTOCOLNUM ] + ' up load end');PROTOCOL ^. DISPOSEFILELIST
(UPLOADLIST , FILELISTSIZE );DISPOSE (PROTOCOL , DONE );CMDSTATE := CMDSTATE AND NOT (CTCMDXFER OR CTCMDXFERSTAT )END END
;IF (CMDSTATE AND CTCMDXFERSTAT <> 0 )AND (TIMEREXPIRED (TERMTIMER ))THEN BEGIN NEWTIMERSECS (TERMTIMER , CTXFERLOGWAIT
);IF PROTOCOL ^. BYTESTRANSFERRED > 0 THEN BEGIN OOIllIO00O0I := XFERSTATUSSTR ;UPDATELOGRAW (OOIllIO00O0I , BYTE
(OOIllIO00O0I [ 0 ] ))END END END ;PROCEDURE TTERMWIN.INITMODEM ;VAR OI1I1II1lI1:BYTE;BEGIN IF CMDSTATE AND (CTCMDRESPREC
OR CTCMDRESPTIME )=0 THEN BEGIN IF TERMREC ^. INITSTR <> ''THEN WITH GENOPTSREC^ DO PUTCMD (TERMREC ^. INITSTR , RESPOK +
CTSEPCHAR + RESPERROR , WAITRESP )ELSE CMDSTATE := CMDSTATE AND NOT CTCMDINIT END ELSE BEGIN IF CMDSTATE AND CTCMDRESPREC
=0 THEN UPDATELOG ('Response time out');CMDSTATE := (CMDSTATE AND NOT (CTCMDINIT OR CTCMDRESPREC OR CTCMDRESPTIME ))OR
CTCMDGENPAUSE END END ;PROCEDURE TTERMWIN.DIALLOG (RAW:BOOLEAN);VAR Ol00IO0I1lII:STRING ;BEGIN Ol00IO0I1lII := INTTOSTR
(GENOPTSREC ^. REDIAL - REDIALCNT + 1 )+ ' of '+ INTTOSTR (GENOPTSREC ^. REDIAL + 1 )+ ', '+ RESPSTR ;IF RAW THEN
UPDATELOGRAW (Ol00IO0I1lII , BYTE (Ol00IO0I1lII [ 0 ] ))ELSE UPDATELOGRAW (Ol00IO0I1lII , 0 )END ;
PROCEDURE TTERMWIN.DIAL ;BEGIN IF CMDSTATE AND (CTCMDRESPREC OR CTCMDRESPTIME )=0 THEN BEGIN IF TERMREC ^. PHONENUM <>
''THEN BEGIN IF REDIALCNT =GENOPTSREC ^. REDIAL THEN UPDATELOG (TERMREC ^. NAME + ', '+ TERMREC ^. PHONENUM + ', ');
RESPSTR := 'DIALING';DIALLOG (TRUE );WITH GENOPTSREC^ DO PUTCMD (GENOPTSREC ^. DIALPREFIX + TERMREC ^. PHONENUM ,
RESPCONNECT + CTSEPCHAR + RESPERROR + CTSEPCHAR + RESPNOCARR + CTSEPCHAR + RESPNOANS + CTSEPCHAR + RESPNOTONE + CTSEPCHAR
+ RESPBUSY , GENOPTSREC ^. DIALWAIT );END ELSE CMDSTATE := CMDSTATE AND NOT CTCMDDIAL END ELSE BEGIN IF CMDSTATE AND
CTCMDRESPREC <> 0 THEN BEGIN IF RESPSTR <> GENOPTSREC ^. RESPCONNECT THEN BEGIN DIALLOG (TRUE );NEWTIMERSECS (TERMTIMER ,
GENOPTSREC ^. DIALPAUSE );CMDSTATE := CMDSTATE OR CTCMDDIALPAUSE OR CTCMDHANGUP END ELSE DIALLOG (FALSE )END ELSE
BEGIN RESPSTR := 'TIME OUT';DIALLOG (TRUE );NEWTIMERSECS (TERMTIMER , GENOPTSREC ^. DIALPAUSE );CMDSTATE := CMDSTATE OR
CTCMDDIALPAUSE OR CTCMDHANGUP END ;CMDSTATE := CMDSTATE AND NOT (CTCMDDIAL OR CTCMDRESPREC OR CTCMDRESPTIME )END END ;
PROCEDURE TTERMWIN.DIALPAUSE ;BEGIN IF REDIALCNT > 0 THEN BEGIN IF TIMEREXPIRED (TERMTIMER )THEN BEGIN DEC (REDIALCNT );
CMDSTATE := (CMDSTATE AND NOT CTCMDDIALPAUSE )OR CTCMDDIAL END END ELSE BEGIN DIALLOG (FALSE );UPDATELOG
('Unable to connect after '+ INTTOSTR (GENOPTSREC ^. REDIAL + 1 )+ ' attempts');CMDSTATE := (CMDSTATE AND NOT
(CTCMDDIALPAUSE OR CTCMDSCRIPT ))OR CTCMDHANGUP END END ;PROCEDURE TTERMWIN.GENPAUSE ;BEGIN IF CMDSTATE AND CTCMDRESPTIME
<> 0 THEN BEGIN IF TIMEREXPIRED (TERMTIMER )THEN CMDSTATE := CMDSTATE AND NOT (CTCMDGENPAUSE OR CTCMDRESPTIME )END ELSE
BEGIN NEWTIMERSECS (TERMTIMER , CTGENWAIT );CMDSTATE := CMDSTATE OR CTCMDRESPTIME END END ;
PROCEDURE TTERMWIN.PROCESSSCRIPT ;BEGIN IF SCRIPTENG <> NIL THEN BEGIN IF SCRIPTENG ^. NODECOLLPTR ^. COUNT > 0 THEN
SCRIPTENG ^. PROCESSCOMMAND ELSE BEGIN CMDSTATE := CMDSTATE AND NOT CTCMDSCRIPT ;UPDATELOG ('Script collection empty')END
END ELSE BEGIN UPDATELOG ('Script collection nil');CMDSTATE := CMDSTATE AND NOT CTCMDSCRIPT END END ;
PROCEDURE TTERMWIN.IDLETASK ;BEGIN IF CMDSTATE =0 THEN TERM ^. PROCINBUF ELSE BEGIN IF CMDSTATE AND CTCMDCTSWAIT =0 THEN
BEGIN IF CMDSTATE AND CTCMDHANGUP =0 THEN BEGIN IF CMDSTATE AND CTCMDRESPWAIT =0 THEN BEGIN IF CMDSTATE AND CTCMDGENPAUSE
<> 0 THEN GENPAUSE ELSE IF CMDSTATE AND CTCMDINIT <> 0 THEN INITMODEM ELSE IF CMDSTATE AND CTCMDDIAL <> 0 THEN DIAL ELSE
IF CMDSTATE AND CTCMDDIALPAUSE <> 0 THEN DIALPAUSE ELSE IF CMDSTATE AND CTCMDXFER <> 0 THEN XFERTASK ELSE IF CMDSTATE AND
CTCMDXFERINIT <> 0 THEN INITXFER ELSE IF CMDSTATE AND CTCMDSCRIPT <> 0 THEN PROCESSSCRIPT END ELSE GETRESP END ELSE
HANGUP END ELSE WAITCTSLOW END END ;PROCEDURE TTERMWIN.CAPTURE (FNAME:PATHSTR;CMD:WORD);BEGIN IF NOT CAPTUREON THEN
BEGIN CAPFILENAME := FNAME ;ASSIGN (CAPFILE , CAPFILENAME );{$I-}RESET (CAPFILE );{$I+}IF IORESULT =0 THEN
BEGIN {$I-}SYSTEM.CLOSE (CAPFILE );{$I+}IF CMD =0 THEN CMD := MESSAGEBOX
(#3'File exists.  Append?'#13#13#3'Yes = Append, No = Erase', NIL , MFCONFIRMATION OR MFYESNOCANCEL );CASE CMD  OF CMYES
:BEGIN {$I-}RESET (CAPFILE );{$I+}IF IORESULT =0 THEN BEGIN {$I-}SEEK (CAPFILE , FILESIZE (CAPFILE ));{$I+}IF IORESULT =0
THEN BEGIN UPDATELOG ('Capture append    '+ CAPFILENAME );CAPTUREON := TRUE END END END ;CMNO :BEGIN {$I-}REWRITE
(CAPFILE );{$I+}IF IORESULT =0 THEN BEGIN UPDATELOG ('Capture overwrite '+ CAPFILENAME );CAPTUREON := TRUE END END END
END ELSE BEGIN {$I-}REWRITE (CAPFILE );{$I+}IF IORESULT =0 THEN BEGIN UPDATELOG ('Capture new file  '+ CAPFILENAME );
CAPTUREON := TRUE END END END ELSE CAPTURECLOSE END ;PROCEDURE TTERMWIN.CAPTURECLOSE ;BEGIN IF CAPTUREON THEN
BEGIN UPDATELOG ('Capture close     '+ CAPFILENAME );{$I-}SYSTEM.CLOSE (CAPFILE );{$I+}CAPTUREON := FALSE END END ;
PROCEDURE TTERMWIN.SETSTATE (ASTATE:WORD;ENABLE:BOOLEAN);BEGIN INHERITED SETSTATE(ASTATE , ENABLE );IF ASTATE =SFACTIVE
THEN BEGIN IF ENABLE THEN ENABLECOMMANDS (PXETERMCMDS )ELSE DISABLECOMMANDS (PXETERMCMDS )END END ;
PROCEDURE TTERMWIN.HANDLEEVENT (VAR EVENT:TEVENT);BEGIN INHERITED HANDLEEVENT(EVENT );IF (EVENT.WHAT =EVBROADCAST )AND
(EVENT.COMMAND =CMTERMIDLE )THEN IDLETASK END ;FUNCTION TTERMWIN.VALID (COMMAND:WORD):BOOLEAN ;VAR OIOI100IlI0:BOOLEAN;
BEGIN OIOI100IlI0 := INHERITED VALID(COMMAND );IF COMMAND =CMCLOSE THEN OIOI100IlI0 := (CMDSTATE AND CTCMDXFERMASK =0 );
VALID := OIOI100IlI0 END ;FUNCTION TPHONECOLLECTION.KEYOF (ITEM:POINTER):POINTER ;BEGIN KEYOF := @ PTERMREC (ITEM )^.
NAME END ;FUNCTION TPHONECOLLECTION.COMPARE (KEY1,KEY2:POINTER):INTEGER ;BEGIN IF PSTRING (KEY1 )^=PSTRING (KEY2 )^THEN
COMPARE := 0 ELSE IF PSTRING (KEY1 )^< PSTRING (KEY2 )^THEN COMPARE := - 1 ELSE COMPARE := 1 END ;
FUNCTION TTERMLISTBOX.GETTEXT (ITEM:INTEGER;MAXLEN:INTEGER):STRING ;VAR OO10:PTERMREC;BEGIN IF LIST <> NIL THEN
BEGIN OO10 := PTERMREC (LIST ^. AT (ITEM ));GETTEXT := PADRIGHTSTR (OO10 ^. NAME , ' ', SIZEOF (OO10 ^. NAME )- 1 )+ ''+
PADRIGHTSTR (OO10 ^. PHONENUM , ' ', SIZEOF (OO10 ^. PHONENUM )- 1 )+ ''+ 'COM'+ INTTOSTR (INTEGER (OO10 ^. COMNAME )+ 1
)+ ''+ INTTORIGHTSTR (OO10 ^. BAUD , 6 )+ ''+ INTTOSTR (OO10 ^. DATABITS )+ CTPARITYCHAR [ BYTE (OO10 ^. PARITY )] +
INTTOSTR (OO10 ^. STOPBITS )END ELSE GETTEXT := ''END ;CONSTRUCTOR TTERMCONFIGDLG.INIT ;VAR OO1I:TRECT;
OOIOI1II00l1:PSCROLLBAR;BEGIN OO1I.ASSIGN (0 , 0 , 75 , 21 );INHERITED INIT(OO1I , 'Phone Book');OPTIONS := OPTIONS OR
OFCENTERED ;OO1I.ASSIGN (72 , 3 , 73 , 7 );NEW (OOIOI1II00l1 , INIT (OO1I ));INSERT (OOIOI1II00l1 );OO1I.ASSIGN (2 , 3 ,
72 , 7 );FIELDBOX := NEW (PTERMLISTBOX , INIT (OO1I , 1 , OOIOI1II00l1 ));INSERT (FIELDBOX );OO1I.ASSIGN (1 , 2 , 22 , 3
);INSERT (NEW (PLABEL , INIT (OO1I , '~L~ist', FIELDBOX )));OO1I.ASSIGN (2 , 8 , 29 , 9 );NAMELINE := NEW (PINPUTLINE ,
INIT (OO1I , 25 ));INSERT (NAMELINE );OO1I.ASSIGN (1 , 7 , 6 , 8 );INSERT (NEW (PLABEL , INIT (OO1I , '~N~ame', NAMELINE
)));OO1I.ASSIGN (30 , 8 , 51 , 9 );PHONELINE := NEW (PINPUTLINE , INIT (OO1I , 25 ));INSERT (PHONELINE );OO1I.ASSIGN (29
, 7 , 35 , 8 );INSERT (NEW (PLABEL , INIT (OO1I , '~P~hone', PHONELINE )));OO1I.ASSIGN (2 , 10 , 29 , 11 );PATHLINE :=
NEW (PINPUTLINE , INIT (OO1I , SIZEOF (PATHSTR )- 1 ));INSERT (PATHLINE );OO1I.ASSIGN (1 , 9 , 16 , 10 );INSERT (NEW
(PLABEL , INIT (OO1I , 'Down load pat~h~', PATHLINE )));OO1I.ASSIGN (30 , 10 , 51 , 11 );INITLINE := NEW (PINPUTLINE ,
INIT (OO1I , 30 ));INSERT (INITLINE );OO1I.ASSIGN (29 , 9 , 47 , 10 );INSERT (NEW (PLABEL , INIT (OO1I ,
'~M~odem init string', INITLINE )));OO1I.ASSIGN (52 , 8 , 73 , 11 );COMBUTTONS := NEW (PRADIOBUTTONS , INIT (OO1I ,
NEWSITEM ('1', NEWSITEM ('2', NEWSITEM ('3', NEWSITEM ('4', NEWSITEM ('5', NEWSITEM ('6', NEWSITEM ('7', NEWSITEM ('8',
NIL ))))))))));INSERT (COMBUTTONS );OO1I.ASSIGN (51 , 7 , 55 , 8 );INSERT (NEW (PLABEL , INIT (OO1I , '~C~om', COMBUTTONS
)));OO1I.ASSIGN (2 , 12 , 35 , 15 );BAUDBUTTONS := NEW (PRADIOBUTTONS , INIT (OO1I , NEWSITEM ('300', NEWSITEM ('1200',
NEWSITEM ('2400', NEWSITEM ('4800', NEWSITEM ('9600', NEWSITEM ('19200', NEWSITEM ('38400', NEWSITEM ('57600', NEWSITEM
('115200', NIL )))))))))));INSERT (BAUDBUTTONS );OO1I.ASSIGN (1 , 11 , 6 , 12 );INSERT (NEW (PLABEL , INIT (OO1I ,
'~B~aud', BAUDBUTTONS )));OO1I.ASSIGN (36 , 12 , 50 , 15 );DATABUTTONS := NEW (PRADIOBUTTONS , INIT (OO1I , NEWSITEM
('5', NEWSITEM ('6', NEWSITEM ('7', NEWSITEM ('8', NIL ))))));INSERT (DATABUTTONS );OO1I.ASSIGN (35 , 11 , 45 , 12 );
INSERT (NEW (PLABEL , INIT (OO1I , 'Da~t~a bits', DATABUTTONS )));OO1I.ASSIGN (51 , 12 , 65 , 15 );PARITYBUTTONS := NEW
(PRADIOBUTTONS , INIT (OO1I , NEWSITEM ('N', NEWSITEM ('O', NEWSITEM ('E', NEWSITEM ('M', NEWSITEM ('S', NIL )))))));
INSERT (PARITYBUTTONS );OO1I.ASSIGN (50 , 11 , 57 , 12 );INSERT (NEW (PLABEL , INIT (OO1I , 'Parit~y~', PARITYBUTTONS
)));OO1I.ASSIGN (66 , 12 , 73 , 15 );STOPBUTTONS := NEW (PRADIOBUTTONS , INIT (OO1I , NEWSITEM ('1', NEWSITEM ('2', NIL
))));INSERT (STOPBUTTONS );OO1I.ASSIGN (65 , 11 , 70 , 12 );INSERT (NEW (PLABEL , INIT (OO1I , '~S~top', STOPBUTTONS )));
OO1I.ASSIGN (2 , 16 , 42 , 19 );OPTBOXES := NEW (PCHECKBOXES , INIT (OO1I , NEWSITEM ('Use DTR', NEWSITEM ('Use RTS',
NEWSITEM ('Req DSR', NEWSITEM ('Req CTS', NEWSITEM ('XON/XOFF', NEWSITEM ('FIFO', NEWSITEM ('Echo', NEWSITEM ('VT100',
NEWSITEM ('Raw Cap', NIL )))))))))));INSERT (OPTBOXES );OO1I.ASSIGN (1 , 15 , 14 , 16 );INSERT (NEW (PLABEL , INIT (OO1I
, '~O~ptions', OPTBOXES )));OO1I.ASSIGN (43 , 16 , 53 , 18 );INSERT (NEW (PBUTTON , INIT (OO1I , 'O~K~', CMOK , BFDEFAULT
)));OO1I.ASSIGN (53 , 16 , 63 , 18 );INSERT (NEW (PBUTTON , INIT (OO1I , '~A~dd', CMPHONEADD , BFNORMAL )));OO1I.ASSIGN
(63 , 16 , 73 , 18 );INSERT (NEW (PBUTTON , INIT (OO1I , '~D~elete', CMPHONEDELETE , BFNORMAL )));OO1I.ASSIGN (43 , 18 ,
53 , 20 );INSERT (NEW (PBUTTON , INIT (OO1I , '~E~dit', CMPHONEEDIT , BFNORMAL )));OO1I.ASSIGN (54 , 18 , 64 , 20 );
INSERT (NEW (PBUTTON , INIT (OO1I , 'Cancel', CMCANCEL , BFNORMAL )));SELECTNEXT (FALSE )END ;
PROCEDURE TTERMCONFIGDLG.ADDREC ;VAR OO10:PTERMREC;FUNCTION O10l (OI1000l1II00:POINTER):BOOLEAN ;FAR ;BEGIN O10l :=
(UPCASESTR (PTERMREC (OI1000l1II00 )^. NAME )=UPCASESTR (NAMELINE ^. DATA ^))END ;BEGIN IF NAMELINE ^. DATA ^<> ''THEN
BEGIN IF PHONECOLLPTR ^. FIRSTTHAT (@ O10l )=NIL THEN BEGIN OO10 := NEW (PTERMREC , INIT );WITH OO10^ DO BEGIN NAME :=
NAMELINE ^. DATA ^;PHONENUM := PHONELINE ^. DATA ^;DLPATH := UPCASESTR (PATHLINE ^. DATA ^);INITSTR := UPCASESTR
(INITLINE ^. DATA ^);COMNAME := COMNAMETYPE (COMBUTTONS ^. VALUE );BAUD := CTBAUDTABLE [ BAUDBUTTONS ^. VALUE ] ;PARITY
:= PARITYTYPE (PARITYBUTTONS ^. VALUE );DATABITS := DATABITTYPE (DATABUTTONS ^. VALUE )+ 5 ;STOPBITS := STOPBITTYPE
(STOPBUTTONS ^. VALUE )+ 1 ;COMOPTIONS := PTRETURNDELIMITER + PTEXECUTEPARTIALPUTS + PTDROPMODEMONCLOSE +
PTRAISEMODEMONOPEN + PTRESTOREONCLOSE ;TERMOPTS := OPTBOXES ^. VALUE END ;PHONECOLLPTR ^. INSERT (OO10 );FIELDBOX ^.
SETRANGE (FIELDBOX ^. LIST ^. COUNT );FIELDBOX ^. FOCUSITEM (PHONECOLLPTR ^. INDEXOF (OO10 ));FIELDBOX ^. DRAWVIEW END
ELSE BEGIN MESSAGEBOX (#3'Duplicate name', NIL , MFERROR OR MFOKBUTTON );NAMELINE ^. FOCUS END END ELSE BEGIN MESSAGEBOX
(#3'Name blank', NIL , MFERROR OR MFOKBUTTON );NAMELINE ^. FOCUS END END ;PROCEDURE TTERMCONFIGDLG.DELETEREC ;BEGIN IF
FIELDBOX ^. RANGE > 0 THEN BEGIN PHONECOLLPTR ^. ATDELETE (FIELDBOX ^. FOCUSED );FIELDBOX ^. SETRANGE (FIELDBOX ^. LIST
^. COUNT );FIELDBOX ^. DRAWVIEW END END ;PROCEDURE TTERMCONFIGDLG.HANDLEEVENT (VAR EVENT:TEVENT);PROCEDURE O101111I1II01
;VAR OO10:PTERMREC;OIlO:INTEGER;BEGIN IF FIELDBOX ^. RANGE > 0 THEN BEGIN OO10 := PHONECOLLPTR ^. AT (FIELDBOX ^. FOCUSED
);WITH OO10^ DO BEGIN NAMELINE ^. SETDATA (NAME );PHONELINE ^. SETDATA (PHONENUM );PATHLINE ^. SETDATA (DLPATH );
INITLINE ^. SETDATA (INITSTR );OIlO := INTEGER (COMNAME );COMBUTTONS ^. SETDATA (OIlO );OIlO := 0 ;WHILE CTBAUDTABLE [
OIlO ] <> BAUD  DO INC (OIlO );BAUDBUTTONS ^. SETDATA (OIlO );OIlO := INTEGER (PARITY );PARITYBUTTONS ^. SETDATA (OIlO );
OIlO := DATABITS - 5 ;DATABUTTONS ^. SETDATA (OIlO );OIlO := STOPBITS - 1 ;STOPBUTTONS ^. SETDATA (OIlO );OPTBOXES ^.
SETDATA (TERMOPTS )END END END ;BEGIN IF ((EVENT.WHAT =EVMOUSEDOWN )AND (EVENT.DOUBLE )AND (FIELDBOX ^. MOUSEINVIEW
(EVENT.WHERE )))THEN BEGIN EVENT.WHAT := EVCOMMAND ;EVENT.COMMAND := CMOK ;PUTEVENT (EVENT );CLEAREVENT (EVENT )END ;
INHERITED HANDLEEVENT(EVENT );CASE EVENT.WHAT  OF EVCOMMAND :BEGIN CASE EVENT.COMMAND  OF CMPHONEADD :ADDREC ;
CMPHONEDELETE :DELETEREC ;CMPHONEEDIT :O101111I1II01 ELSE EXIT END ;CLEAREVENT (EVENT )END END END ;
CONSTRUCTOR TTERMGENDLG.INIT ;VAR OO1I:TRECT;OIO1000lI0l:PINPUTLINE;BEGIN OO1I.ASSIGN (0 , 0 , 52 , 14 );
INHERITED INIT(OO1I , 'Terminal');OPTIONS := OPTIONS OR OFCENTERED ;OO1I.ASSIGN (2 , 3 , 9 , 4 );OIO1000lI0l := NEW
(PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (80 , 132 )));INSERT
(OIO1000lI0l );OO1I.ASSIGN (1 , 2 , 7 , 3 );INSERT (NEW (PLABEL , INIT (OO1I , 'Width', OIO1000lI0l )));OO1I.ASSIGN (10 ,
3 , 17 , 4 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT
(50 , 1000 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (9 , 2 , 16 , 3 );INSERT (NEW (PLABEL , INIT (OO1I , 'Length',
OIO1000lI0l )));OO1I.ASSIGN (18 , 3 , 25 , 4 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^.
SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (1 , 8192 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (17 , 2 , 22 , 3 );INSERT (NEW
(PLABEL , INIT (OO1I , 'Draw', OIO1000lI0l )));OO1I.ASSIGN (26 , 3 , 33 , 4 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I
, 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (2048 , 32768 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (25 ,
2 , 31 , 3 );INSERT (NEW (PLABEL , INIT (OO1I , 'Input', OIO1000lI0l )));OO1I.ASSIGN (34 , 3 , 41 , 4 );OIO1000lI0l :=
NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (2048 , 32768 )));INSERT
(OIO1000lI0l );OO1I.ASSIGN (33 , 2 , 40 , 3 );INSERT (NEW (PLABEL , INIT (OO1I , 'Output', OIO1000lI0l )));OO1I.ASSIGN
(42 , 3 , 49 , 4 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR ,
INIT (1 , 60 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (41 , 2 , 50 , 3 );INSERT (NEW (PLABEL , INIT (OO1I , 'CTS wait',
OIO1000lI0l )));OO1I.ASSIGN (2 , 5 , 24 , 6 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 20 ));INSERT (OIO1000lI0l );
OO1I.ASSIGN (1 , 4 , 13 , 5 );INSERT (NEW (PLABEL , INIT (OO1I , 'Dial prefix', OIO1000lI0l )));OO1I.ASSIGN (26 , 5 , 33
, 6 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (1 ,
3600 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (25 , 4 , 30 , 5 );INSERT (NEW (PLABEL , INIT (OO1I , 'Wait', OIO1000lI0l )));
OO1I.ASSIGN (34 , 5 , 41 , 6 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW
(PRANGEVALIDATOR , INIT (1 , 3600 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (33 , 4 , 39 , 5 );INSERT (NEW (PLABEL , INIT
(OO1I , 'Pause', OIO1000lI0l )));OO1I.ASSIGN (42 , 5 , 49 , 6 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 6 ));
OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (1 , 1000 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (41 , 4 , 50 , 5
);INSERT (NEW (PLABEL , INIT (OO1I , 'Redial', OIO1000lI0l )));OO1I.ASSIGN (2 , 7 , 9 , 8 );OIO1000lI0l := NEW
(PINPUTLINE , INIT (OO1I , 30 ));INSERT (OIO1000lI0l );OO1I.ASSIGN (1 , 6 , 4 , 7 );INSERT (NEW (PLABEL , INIT (OO1I ,
'OK', OIO1000lI0l )));OO1I.ASSIGN (10 , 7 , 17 , 8 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 30 ));INSERT
(OIO1000lI0l );OO1I.ASSIGN (9 , 6 , 15 , 7 );INSERT (NEW (PLABEL , INIT (OO1I , 'Error', OIO1000lI0l )));OO1I.ASSIGN (18
, 7 , 25 , 8 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 30 ));INSERT (OIO1000lI0l );OO1I.ASSIGN (17 , 6 , 25 , 7 );
INSERT (NEW (PLABEL , INIT (OO1I , 'Connect', OIO1000lI0l )));OO1I.ASSIGN (26 , 7 , 33 , 8 );OIO1000lI0l := NEW
(PINPUTLINE , INIT (OO1I , 30 ));INSERT (OIO1000lI0l );OO1I.ASSIGN (25 , 6 , 33 , 7 );INSERT (NEW (PLABEL , INIT (OO1I ,
'No carr', OIO1000lI0l )));OO1I.ASSIGN (34 , 7 , 41 , 8 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 30 ));INSERT
(OIO1000lI0l );OO1I.ASSIGN (33 , 6 , 40 , 7 );INSERT (NEW (PLABEL , INIT (OO1I , 'No ans', OIO1000lI0l )));OO1I.ASSIGN
(42 , 7 , 49 , 8 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 30 ));INSERT (OIO1000lI0l );OO1I.ASSIGN (41 , 6 , 46 , 7
);INSERT (NEW (PLABEL , INIT (OO1I , 'Busy', OIO1000lI0l )));OO1I.ASSIGN (2 , 9 , 9 , 10 );OIO1000lI0l := NEW (PINPUTLINE
, INIT (OO1I , 30 ));INSERT (OIO1000lI0l );OO1I.ASSIGN (1 , 8 , 7 , 9 );INSERT (NEW (PLABEL , INIT (OO1I , 'Voice',
OIO1000lI0l )));OO1I.ASSIGN (10 , 9 , 17 , 10 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 30 ));INSERT (OIO1000lI0l
);OO1I.ASSIGN (9 , 8 , 14 , 9 );INSERT (NEW (PLABEL , INIT (OO1I , 'Ring', OIO1000lI0l )));OO1I.ASSIGN (18 , 9 , 25 , 10
);OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 30 ));INSERT (OIO1000lI0l );OO1I.ASSIGN (17 , 8 , 25 , 9 );INSERT (NEW
(PLABEL , INIT (OO1I , 'No tone', OIO1000lI0l )));OO1I.ASSIGN (26 , 9 , 33 , 10 );OIO1000lI0l := NEW (PINPUTLINE , INIT
(OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (0 , 255 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (25
, 8 , 33 , 9 );INSERT (NEW (PLABEL , INIT (OO1I , 'Can chr', OIO1000lI0l )));OO1I.ASSIGN (34 , 9 , 41 , 10 );OIO1000lI0l
:= NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR , INIT (1 , 60 )));INSERT
(OIO1000lI0l );OO1I.ASSIGN (33 , 8 , 41 , 9 );INSERT (NEW (PLABEL , INIT (OO1I , 'Re wait', OIO1000lI0l )));OO1I.ASSIGN
(42 , 9 , 49 , 10 );OIO1000lI0l := NEW (PINPUTLINE , INIT (OO1I , 6 ));OIO1000lI0l ^. SETVALIDATOR (NEW (PRANGEVALIDATOR
, INIT (1 , 60 )));INSERT (OIO1000lI0l );OO1I.ASSIGN (41 , 8 , 49 , 9 );INSERT (NEW (PLABEL , INIT (OO1I , 'DTR low',
OIO1000lI0l )));OO1I.ASSIGN (15 , 11 , 25 , 13 );INSERT (NEW (PBUTTON , INIT (OO1I , 'O~K~', CMOK , BFDEFAULT )));
OO1I.ASSIGN (26 , 11 , 36 , 13 );INSERT (NEW (PBUTTON , INIT (OO1I , 'Cancel', CMCANCEL , BFNORMAL )));SELECTNEXT (FALSE
)END ;END .
